<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>rejester._task_master &mdash; streamcorpus-pipeline 0.7.10.dev1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.10.dev1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="streamcorpus-pipeline 0.7.10.dev1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">streamcorpus-pipeline 0.7.10.dev1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for rejester._task_master</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;External API for rejester task system.</span>

<span class="sd">.. This software is released under an MIT/X11 open source license.</span>
<span class="sd">   Copyright 2012-2015 Diffeo, Inc.</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="kn">from</span> <span class="nn">rejester._registry</span> <span class="kn">import</span> <span class="n">Registry</span><span class="p">,</span> <span class="n">nice_identifier</span>
<span class="kn">from</span> <span class="nn">rejester.exceptions</span> <span class="kn">import</span> <span class="n">ProgrammerError</span><span class="p">,</span> <span class="n">LockError</span><span class="p">,</span> \
    <span class="n">LostLease</span><span class="p">,</span> <span class="ne">EnvironmentError</span><span class="p">,</span> <span class="n">NoSuchWorkSpecError</span><span class="p">,</span> <span class="n">NoSuchWorkUnitError</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">BUNDLES</span> <span class="o">=</span> <span class="s">&#39;bundles&#39;</span>
<span class="n">NICE_LEVELS</span> <span class="o">=</span> <span class="s">&#39;NICE_LEVELS&#39;</span>
<span class="n">WORK_SPECS</span> <span class="o">=</span> <span class="s">&#39;WORK_SPECS&#39;</span>
<span class="n">WORK_UNITS_</span> <span class="o">=</span> <span class="s">&#39;WORK_UNITS_&#39;</span>
<span class="n">_BLOCKED</span> <span class="o">=</span> <span class="s">&#39;_BLOCKED&#39;</span>
<span class="n">_BLOCKS</span> <span class="o">=</span> <span class="s">&#39;_BLOCKS&#39;</span>
<span class="n">_DEPENDS</span> <span class="o">=</span> <span class="s">&#39;_DEPENDS&#39;</span>
<span class="n">_FINISHED</span> <span class="o">=</span> <span class="s">&#39;_FINISHED&#39;</span>
<span class="n">_FAILED</span> <span class="o">=</span> <span class="s">&#39;_FAILED&#39;</span>
<span class="n">WORKER_CHILDREN_</span> <span class="o">=</span> <span class="s">&#39;WORKER_CHILDREN_&#39;</span>
<span class="n">WORKER_STATE_</span> <span class="o">=</span> <span class="s">&#39;WORKER_STATE_&#39;</span>
<span class="n">WORKER_OBSERVED_MODE</span> <span class="o">=</span> <span class="s">&#39;WORKER_OBSERVED_MODE&#39;</span>
<span class="n">ACTIVE_LEASES</span> <span class="o">=</span> <span class="s">&#39;ACTIVE_LEASES&#39;</span>


<span class="c">## work unit states</span>
<span class="n">AVAILABLE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">BLOCKED</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">PENDING</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">FINISHED</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">FAILED</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">WORK_UNIT_STATUS_BY_NAME</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;AVAILABLE&#39;</span><span class="p">:</span> <span class="n">AVAILABLE</span><span class="p">,</span>
    <span class="s">&#39;BLOCKED&#39;</span><span class="p">:</span> <span class="n">BLOCKED</span><span class="p">,</span>
    <span class="s">&#39;PENDING&#39;</span><span class="p">:</span> <span class="n">PENDING</span><span class="p">,</span>
    <span class="s">&#39;FINISHED&#39;</span><span class="p">:</span> <span class="n">FINISHED</span><span class="p">,</span>
    <span class="s">&#39;FAILED&#39;</span><span class="p">:</span> <span class="n">FAILED</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">WORK_UNIT_STATUS_NAMES_BY_NUMBER</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">WORK_UNIT_STATUS_BY_NAME</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>
<span class="p">])</span>


<span class="k">def</span> <span class="nf">build_task_master</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">tm_factory_module_name</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;task_master_module&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tm_factory_module_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">importlib</span>
        <span class="n">tm_factory_module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">tm_factory_module_name</span><span class="p">)</span>
        <span class="n">tm_factory_clasname</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;task_master_class&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">tm_factory_clasname</span><span class="p">,</span> <span class="s">&#39;task_master_module set but not task_master_class&#39;</span>
        <span class="n">_task_master_factory</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tm_factory_module</span><span class="p">,</span> <span class="n">tm_factory_clasname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_task_master_factory</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="c"># by default use implementation later in this file</span>
    <span class="k">return</span> <span class="n">TaskMaster</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>


<div class="viewcode-block" id="Worker"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker">[docs]</a><span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Process that runs rejester jobs.</span>

<span class="sd">    Running a worker involves three steps: calling :meth:`register` to</span>
<span class="sd">    get a :attr:`worker_id` and record our presence in the data store;</span>
<span class="sd">    calling :meth:`run` to actually do work; and calling :meth:`unregister`</span>
<span class="sd">    on clean exit.  The :meth:`run` method should periodically call</span>
<span class="sd">    :meth:`heartbeat` to update its state and get the current run mode.</span>

<span class="sd">    ..automethod:: __init__</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">task_master</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a new worker.</span>

<span class="sd">        :param dict config: Configuration for the worker, typically</span>
<span class="sd">          the contents of the ``rejester`` block in the global config</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#: Configuration for the worker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="c">#: Task interface to talk to the data store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span> <span class="o">=</span> <span class="n">task_master</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span> <span class="o">=</span> <span class="n">build_task_master</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>
        <span class="c">#: Worker ID, only valid after :meth:`register`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c">#: Parent worker ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c">#: Required maximum time between :meth:`heartbeat`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lifetime</span> <span class="o">=</span> <span class="mi">300</span> <span class="o">*</span> <span class="mi">20</span>  <span class="c"># 100 minutes</span>

<div class="viewcode-block" id="Worker.environment"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker.environment">[docs]</a>    <span class="k">def</span> <span class="nf">environment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get raw data about this worker.</span>

<span class="sd">        This is recorded in the :meth:`heartbeat` info, and can be</span>
<span class="sd">        retrieved by :meth:`TaskMaster.get_heartbeat`.  The dictionary</span>
<span class="sd">        includes keys ``worker_id``, ``host``, ``fqdn``, ``version``,</span>
<span class="sd">        ``working_set``, and ``memory``.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">hostname</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">()</span>
        <span class="n">aliases</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">ipaddrs</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c"># This sequence isn&#39;t 100% reliable.  We might try a socket()</span>
        <span class="c"># sequence like RedisBase._ipaddress(), or just decide that</span>
        <span class="c"># socket.fqdn() and/or socket.gethostname() is good enough.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyname</span><span class="p">(</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">herror</span><span class="p">:</span>
            <span class="c"># If you&#39;re here, then $(hostname) doesn&#39;t resolve.</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">hostname</span><span class="p">,</span> <span class="n">aliases</span><span class="p">,</span> <span class="n">ipaddrs</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyaddr</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">herror</span><span class="p">:</span>
            <span class="c"># If you&#39;re here, then $(hostname) resolves, but the IP</span>
            <span class="c"># address that results in doesn&#39;t reverse-resolve.  This</span>
            <span class="c"># has been observed on OSX at least.</span>
            <span class="n">ipaddrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ip</span><span class="p">,)</span>

        <span class="n">env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">worker_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">aliases</span><span class="p">),</span>
            <span class="n">ipaddrs</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ipaddrs</span><span class="p">),</span>
            <span class="n">fqdn</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">getfqdn</span><span class="p">(),</span>
            <span class="n">version</span><span class="o">=</span><span class="n">pkg_resources</span><span class="o">.</span><span class="n">get_distribution</span><span class="p">(</span><span class="s">&quot;rejester&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">version</span><span class="p">,</span> <span class="c"># pylint: disable=E1103</span>
            <span class="n">working_set</span><span class="o">=</span><span class="p">[(</span><span class="n">dist</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">version</span><span class="p">)</span> <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">WorkingSet</span><span class="p">()],</span> <span class="c"># pylint: disable=E1103</span>
            <span class="c"># config_hash=self.config[&#39;config_hash&#39;],</span>
            <span class="c"># config_json = self.config[&#39;config_json&#39;],</span>
            <span class="n">memory</span><span class="o">=</span><span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">(),</span>
            <span class="n">pid</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">env</span>
</div>
<div class="viewcode-block" id="Worker.register"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Record the availability of this worker and get a unique identifer.</span>

<span class="sd">        This sets :attr:`worker_id` and calls :meth:`heartbeat`.  This</span>
<span class="sd">        cannot be called multiple times without calling</span>
<span class="sd">        :meth:`unregister` in between.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;Worker.register cannot be called again without first calling unregister; it is not idempotent&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="n">nice_identifier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heartbeat</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span>
</div>
<div class="viewcode-block" id="Worker.unregister"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker.unregister">[docs]</a>    <span class="k">def</span> <span class="nf">unregister</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove this worker from the list of available workers.</span>

<span class="sd">        This requires the worker to already have been :meth:`register()`.</span>

<span class="sd">        &#39;&#39;&#39;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span><span class="o">.</span><span class="n">worker_unregister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Worker.heartbeat"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker.heartbeat">[docs]</a>    <span class="k">def</span> <span class="nf">heartbeat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Record the current worker state in the registry.</span>

<span class="sd">        This records the worker&#39;s current mode, plus the contents of</span>
<span class="sd">        :meth:`environment`, in the data store for inspection by others.</span>

<span class="sd">        :returns mode: Current mode, as :meth:`TaskMaster.get_mode`</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_master</span><span class="o">.</span><span class="n">worker_heartbeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">lifetime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">(),</span>
                                          <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mode</span>
</div>
    <span class="nd">@abc.abstractmethod</span>
<div class="viewcode-block" id="Worker.run"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.Worker.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Run some number of jobs.</span>

<span class="sd">        :meth:`register` must have already been called.  This is</span>
<span class="sd">        expected to get jobs using :meth:`TaskMaster.get_work` with</span>
<span class="sd">        this worker&#39;s :attr:`worker_id`.  Depending on the semantics</span>
<span class="sd">        of the actual implementing class this may run one job, run</span>
<span class="sd">        jobs as long as the worker&#39;s mode is :attr:`~TaskMaster.RUN`,</span>
<span class="sd">        or any other combination.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span>

</div></div>
<div class="viewcode-block" id="WorkUnit"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit">[docs]</a><span class="k">class</span> <span class="nc">WorkUnit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A single unit of work being executed.</span>

<span class="sd">    These are created by the rejester system; the standard worker</span>
<span class="sd">    system will pass objects of this type to the named run function.</span>
<span class="sd">    If some code calls:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        task_master.update_bundle({ &#39;name&#39;: &#39;work_spec_name&#39;, ... },</span>
<span class="sd">                                  { &#39;key&#39;: data, ... })</span>

<span class="sd">    Then when the work unit is executed, this object will have the</span>
<span class="sd">    provided :attr:`work_spec_name`, :attr:`key`, and :attr:`data`,</span>
<span class="sd">    with remaining values being provided by the system.</span>

<span class="sd">    In the standard worker system, the worker will call :meth:`finish`</span>
<span class="sd">    or :meth:`fail` as appropriate.  The run function should examine</span>
<span class="sd">    :attr:`spec`, :attr:`key`, and :attr:`data` to figure out what to</span>
<span class="sd">    do.</span>

<span class="sd">    .. automethod:: __init__</span>

<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="WorkUnit.__init__"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">registry</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">worker_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">expires</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">default_lifetime</span><span class="o">=</span><span class="mi">900</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a new work unit runtime data.</span>

<span class="sd">        In most cases application code will not need to call this directly,</span>
<span class="sd">        but should expect to be passed work units created by the system.</span>

<span class="sd">        :param registry: Mid-level Redis interface</span>
<span class="sd">        :type registry: :class:`rejester.Registry`</span>
<span class="sd">        :param str work_spec_name: Name of the work spec</span>
<span class="sd">        :param str key: Name of the work unit</span>
<span class="sd">        :param dict data: Data provided for the work unit</span>
<span class="sd">        :param str worker_id: Worker doing this work unit</span>
<span class="sd">        :param int expires: Latest time this work unit can still be running</span>
<span class="sd">        :param int default_lifetime: Time :meth:`update` adds by default</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">worker_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;must specify a worker_id, not: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span>
                                  <span class="n">worker_id</span><span class="p">)</span>
        <span class="c">#: Worker doing this work unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="n">worker_id</span>
        <span class="c">#: Mid-level Redis interface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">registry</span>
        <span class="c">#: Name of the work spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">=</span> <span class="n">work_spec_name</span>
        <span class="c">#: Name of the work unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="c">#: Data provided for the work unit</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;WorkUnit must be given a dict() for &#39;</span>
                                  <span class="s">&#39;data, otherwise exceptions will not &#39;</span>
                                  <span class="s">&#39;get passed back up&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c">#: Has this work unit called :meth:`finish`?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c">#: Has this work unit called :meth:`fail`?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c">#: Time (as :func:`time.time`) when this work unit must finish</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">expires</span>
        <span class="c">#: Time :meth:`update` adds by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span> <span class="o">=</span> <span class="n">default_lifetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spec_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># storage for lazy getter property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># storage for lazy getter property</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&#39;WorkUnit(work_spec_name={0.work_spec_name}, key={0.key})&#39;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Actual work spec.</span>

<span class="sd">        This is retrieved from the database on first use, and in some</span>
<span class="sd">        cases a worker can be mildly more efficient if it avoids using</span>
<span class="sd">        this.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec_cache</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spec_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">WORK_SPECS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec_cache</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Python module to run the job.</span>

<span class="sd">        This is used by :func:`run` and the standard worker system.</span>
<span class="sd">        If the work spec contains keys ``module``, ``run_function``,</span>
<span class="sd">        and ``terminate_function``, then this contains the Python</span>
<span class="sd">        module object named as ``module``; otherwise this contains</span>
<span class="sd">        :const:`None`.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_cache</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">funclist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;run_function&#39;</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;terminate_function&#39;</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">funclist</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_module_cache</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;module&#39;</span><span class="p">],</span> <span class="nb">globals</span><span class="p">(),</span> <span class="p">(),</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;failed to load spec[&quot;module&quot;] = </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;module&#39;</span><span class="p">],</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">raise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_cache</span>

<div class="viewcode-block" id="WorkUnit.run"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Actually runs the work unit.</span>

<span class="sd">        This is called by the standard worker system, generally</span>
<span class="sd">        once per work unit.  It requires the work spec to contain</span>
<span class="sd">        keys ``module``, ``run_function``, and ``terminate_function``.</span>
<span class="sd">        It looks up ``run_function`` in :attr:`module` and calls that</span>
<span class="sd">        function with :const:`self` as its only parameter.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;running work unit {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
            <span class="n">run_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;run_function&#39;</span><span class="p">])</span>
            <span class="n">ret_val</span> <span class="o">=</span> <span class="n">run_function</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;completed work unit {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ret_val</span>
        <span class="k">except</span> <span class="n">LostLease</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;work unit {0} timed out&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;work unit {0} failed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">),</span>
                         <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">raise</span>
</div>
<div class="viewcode-block" id="WorkUnit.terminate"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Kills the work unit.</span>

<span class="sd">        This is called by the standard worker system, but only in</span>
<span class="sd">        response to an operating system signal.  If the job does setup</span>
<span class="sd">        such as creating a child process, its terminate function</span>
<span class="sd">        should kill that child process.  More specifically, this</span>
<span class="sd">        function requires the work spec to contain the keys</span>
<span class="sd">        ``module``, ``run_function``, and ``terminate_function``, and</span>
<span class="sd">        calls ``terminate_function`` in :attr:`module` containing</span>
<span class="sd">        :const:`self` as its only parameter.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">terminate_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;terminate_function&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terminate_function_name</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;tried to terminate WorkUnit(</span><span class="si">%r</span><span class="s">) but no &#39;</span>
                         <span class="s">&#39;function name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">terminate_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;terminate_function&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terminate_function</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;tried to terminate WorkUnit(</span><span class="si">%r</span><span class="s">) but no &#39;</span>
                         <span class="s">&#39;function </span><span class="si">%s</span><span class="s"> in module </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">terminate_function_name</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;calling terminate function for work unit {0}&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="n">terminate_function</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">lease_time</span><span class="o">=-</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret_val</span>
</div>
    <span class="k">def</span> <span class="nf">_refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">stopping</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get this task&#39;s current state.</span>

<span class="sd">        This must be called under the registry&#39;s lock.  It updates</span>
<span class="sd">        the :attr:`finished` and :attr:`failed` flags and the</span>
<span class="sd">        :attr:`data` dictionary based on the current state in the</span>
<span class="sd">        registry.</span>

<span class="sd">        In the normal case, nothing will change and this function</span>
<span class="sd">        will return normally.  If it turns out that the work unit</span>
<span class="sd">        is already finished, the state of this object will change</span>
<span class="sd">        before :exc:`rejester.exceptions.LostLease` is raised.</span>

<span class="sd">        :param session: locked registry session</span>
<span class="sd">        :param stopping: don&#39;t raise if the work unit is finished</span>
<span class="sd">        :raises rejester.exceptions.LostLease: if this worker is</span>
<span class="sd">          no longer doing this work unit</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stopping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span><span class="s">&#39;work unit is already finished&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stopping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span><span class="s">&#39;work unit has already failed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># (You need a pretty specific sequence of events to get here)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span><span class="s">&#39;work unit now blocked by others&#39;</span><span class="p">)</span>

        <span class="n">worker_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">worker_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span><span class="s">&#39;work unit claimed by </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">)</span>

        <span class="c"># NB: We could check the priority here, but don&#39;t.</span>
        <span class="c"># If at this point we&#39;re technically overtime but nobody</span>
        <span class="c"># else has started doing work yet, since we&#39;re under the</span>
        <span class="c"># global lock, we can get away with finishing whatever</span>
        <span class="c"># transition we were going to try to do.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoSuchWorkUnitError</span><span class="p">(</span><span class="s">&#39;work unit is gone&#39;</span><span class="p">)</span>
        <span class="c"># Since we should still own the work unit, any changes</span>
        <span class="c"># in data should be on our end; do not touch it</span>

        <span class="k">return</span>  <span class="c"># we&#39;ve checked everything to check</span>

<div class="viewcode-block" id="WorkUnit.update"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lease_time</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Refresh this task&#39;s expiration time.</span>

<span class="sd">        This tries to set the task&#39;s expiration time to the current</span>
<span class="sd">        time, plus `lease_time` seconds.  It requires the job to not</span>
<span class="sd">        already be complete.  If `lease_time` is negative, makes the</span>
<span class="sd">        job immediately be available for other workers to run.</span>

<span class="sd">        :param int lease_time: time to extend job lease beyond now</span>
<span class="sd">        :raises rejester.exceptions.LostLease: if the lease has already</span>
<span class="sd">          expired</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">lease_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lease_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">lease_time</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span>
                    <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">},</span> 
                    <span class="n">priorities</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">expires</span><span class="p">},</span>
                    <span class="n">locks</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">})</span>

            <span class="k">except</span> <span class="ne">EnvironmentError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                </div>
<div class="viewcode-block" id="WorkUnit.finish"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.finish">[docs]</a>    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Move this work unit to a finished state.</span>

<span class="sd">        In the standard worker system, the worker calls this on the job&#39;s</span>
<span class="sd">        behalf when :meth:`run_function` returns successfully.</span>

<span class="sd">        :raises rejester.exceptions.LostLease: if the lease has already</span>
<span class="sd">          expired</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">stopping</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span>
                <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKS</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c"># hard = block[2]</span>
                    <span class="n">depends</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span>
                                          <span class="n">unit</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">depends</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">depends</span><span class="o">.</span><span class="n">remove</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                        <span class="n">unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                              <span class="n">unit</span><span class="p">)</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                     <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span><span class="p">,</span>
                                     <span class="p">{</span><span class="n">unit</span><span class="p">:</span> <span class="n">unitdef</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span>
                                    <span class="n">depends</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="WorkUnit.fail"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.WorkUnit.fail">[docs]</a>    <span class="k">def</span> <span class="nf">fail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Move this work unit to a failed state.</span>

<span class="sd">        In the standard worker system, the worker calls this on the job&#39;s</span>
<span class="sd">        behalf when :meth:`run_function` ends with any exception:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            try:</span>
<span class="sd">                work_unit.run()</span>
<span class="sd">                work_unit.finish()</span>
<span class="sd">            except Exception, e:</span>
<span class="sd">                work_unit.fail(e)</span>

<span class="sd">        A ``traceback`` property is recorded with a formatted version</span>
<span class="sd">        of `exc`, if any.</span>

<span class="sd">        :param exc: Exception that caused the failure, or :const:`None`</span>
<span class="sd">        :raises rejester.exceptions.LostLease: if the lease has already</span>
<span class="sd">          expired</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">stopping</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKS</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">hard</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                        <span class="n">unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                              <span class="n">unit</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                         <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                                         <span class="p">{</span><span class="n">unit</span><span class="p">:</span> <span class="n">unitdef</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">depends</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span>
                                              <span class="n">unit</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">depends</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">depends</span><span class="o">.</span><span class="n">remove</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                            <span class="n">unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                                  <span class="n">unit</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                             <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span><span class="p">,</span>
                                             <span class="p">{</span><span class="n">unit</span><span class="p">:</span> <span class="n">unitdef</span><span class="p">})</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span>
                                        <span class="n">depends</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="bp">True</span>

</div></div>
<div class="viewcode-block" id="TaskMaster"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster">[docs]</a><span class="k">class</span> <span class="nc">TaskMaster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Control object for the rejester task queue.</span>

<span class="sd">    The task queue consists of a series of *work specs*, which include</span>
<span class="sd">    configuration information, and each work spec has some number of</span>
<span class="sd">    *work units* attached to it.  Both the work specs and work units</span>
<span class="sd">    are defined as (non-empty) dictionaries.  The work spec must have</span>
<span class="sd">    keys ``name`` and ``min_gb``, but any other properties are permitted.</span>
<span class="sd">    Conventionally ``desc`` contains a description of the job and</span>
<span class="sd">    ``config`` contains the top-level global configuration.</span>

<span class="sd">    There are three ways to use :class:`TaskMaster`:</span>

<span class="sd">    1. Create work specs and work units with :meth:`update_bundle`.</span>
<span class="sd">       Directly call :meth:`get_work` to get work units back.  Based</span>
<span class="sd">       on the information stored in the work spec and work unit</span>
<span class="sd">       dictionaries, do the work manually, and call</span>
<span class="sd">       :meth:`WorkUnit.finish` or :meth:`WorkUnit.fail` as</span>
<span class="sd">       appropriate.</span>

<span class="sd">    2. Create work specs and work units with :meth:`update_bundle`.</span>
<span class="sd">       The work spec must contain three keys, ``module`` naming a Python</span>
<span class="sd">       module, and ``run_function`` and ``terminate_function`` each</span>
<span class="sd">       naming functions of a single parameter in that module.  Directly</span>
<span class="sd">       call :meth:`get_work` to get work units back, then call their</span>
<span class="sd">       :meth:`WorkUnit.run` function to execute them.  See the basic</span>
<span class="sd">       example in :meth:`WorkUnit.fail`.</span>

<span class="sd">    3. Create work specs and work units with :meth:`update_bundle`,</span>
<span class="sd">       including the Python information.  Use one of the standard worker</span>
<span class="sd">       implementations in :mod:`rejester.workers` to actually run the</span>
<span class="sd">       job.</span>

<span class="sd">    Most applications will use the third option, the standard worker</span>
<span class="sd">    system.  In all three cases populating and executing jobs can</span>
<span class="sd">    happen on different systems, or on multiple systems in parallel.</span>
<span class="sd">    To use the standard worker system, create a Python module::</span>

<span class="sd">        def rejester_run(work_unit):</span>
<span class="sd">            # Does the actual work for `work_unit`.</span>
<span class="sd">            # Must be a top-level function in the module.</span>
<span class="sd">            # The work unit will succeed if this returns normally,</span>
<span class="sd">            # and will fail if this raises an exception.</span>
<span class="sd">            pass</span>

<span class="sd">        def rejester_terminate(work_unit):</span>
<span class="sd">            # Called only if a signal terminates the worker.</span>
<span class="sd">            # This usually does nothing, but could kill a known subprocess.</span>
<span class="sd">            pass</span>

<span class="sd">    The work spec would look something like::</span>

<span class="sd">        work_spec = {</span>
<span class="sd">            &#39;name&#39;: &#39;rejester_sample&#39;,</span>
<span class="sd">            &#39;desc&#39;: &#39;A sample rejester job.&#39;,</span>
<span class="sd">            &#39;min_gb&#39;: 1,</span>
<span class="sd">            &#39;config&#39;: yakonfig.get_global_config(),</span>
<span class="sd">            &#39;module&#39;: &#39;name.of.the.module.from.above&#39;,</span>
<span class="sd">            &#39;run_function&#39;: &#39;rejester_run&#39;,</span>
<span class="sd">            &#39;terminate_function&#39;: &#39;rejester_terminate&#39;,</span>
<span class="sd">        }</span>

<span class="sd">    The work units can be any non-empty dictionaries that are</span>
<span class="sd">    meaningful to the run function.  :class:`WorkUnit` objects are</span>
<span class="sd">    created with their :attr:`~WorkUnit.key` and :attr:`~WorkUnit.data`</span>
<span class="sd">    fields set to individual keys and values from the parameter to</span>
<span class="sd">    :meth:`update_bundle`.</span>

<span class="sd">    A work unit can be in one of five states.  It is *available* if it</span>
<span class="sd">    has been added to the queue but nobody is working on it.  It is</span>
<span class="sd">    *pending* if somebody is currently working on it.  When they</span>
<span class="sd">    finish, it will become either *finished* or *failed*.  If</span>
<span class="sd">    dependencies are added between tasks using `add_dependent_task()`,</span>
<span class="sd">    a task can also be *blocked*.</span>

<span class="sd">    The general flow for a rejester application is to :meth:`set_mode`</span>
<span class="sd">    to :attr:`IDLE`, then add work units using</span>
<span class="sd">    :meth:`update_bundle()`, and :meth:`set_mode` to :attr:`RUN`.</span>
<span class="sd">    :meth:`get_work` will return work units until all have been</span>
<span class="sd">    consumed.  :meth:`set_mode` to :attr:`TERMINATE` will instruct</span>
<span class="sd">    workers to shut down.</span>

<span class="sd">    This object keeps very little state locally and can safely be used</span>
<span class="sd">    concurrently, including from multiple systems.  Correspondingly,</span>
<span class="sd">    any settings here, including :meth:`set_mode`, are persistent even</span>
<span class="sd">    beyond the end of the current process.</span>

<span class="sd">    .. automethod:: __init__</span>

<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="TaskMaster.__init__"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a new task master.</span>

<span class="sd">        This is a lightweight object, and it is safe to have multiple</span>
<span class="sd">        objects concurrently accessing the same rejester system, even</span>
<span class="sd">        on multiple machines.</span>

<span class="sd">        :param dict config: Configuration for the task master, generally</span>
<span class="sd">          the contents of the ``rejester`` block in the global configuration</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">config</span><span class="p">[</span><span class="s">&#39;app_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;rejester&#39;</span>
        <span class="c">#: Configuration for the task master</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="c">#: Mid-level Redis interface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">Registry</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="c">#: Worker ID, if this is tied to a worker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c">#: Amount of time workers get between :meth:`WorkUnit.update` calls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;default_lifetime&#39;</span><span class="p">,</span> <span class="mi">900</span><span class="p">)</span>
        <span class="c">#: Override available-memory checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enough_memory</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;enough_memory&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="c">#: Mode constant instructing workers to do work</span></div>
    <span class="n">RUN</span> <span class="o">=</span> <span class="s">&#39;RUN&#39;</span>
    <span class="c">#: Mode constant instructing workers to not start new work</span>
    <span class="n">IDLE</span> <span class="o">=</span> <span class="s">&#39;IDLE&#39;</span>
    <span class="c">#: Mode constant instructing workers to shut down</span>
    <span class="n">TERMINATE</span> <span class="o">=</span> <span class="s">&#39;TERMINATE&#39;</span>

    <span class="c"># states for a work unit</span>
    <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="n">AVAILABLE</span>
    <span class="n">BLOCKED</span> <span class="o">=</span> <span class="n">BLOCKED</span>
    <span class="n">PENDING</span> <span class="o">=</span> <span class="n">PENDING</span>
    <span class="n">FINISHED</span> <span class="o">=</span> <span class="n">FINISHED</span>
    <span class="n">FAILED</span> <span class="o">=</span> <span class="n">FAILED</span>

<div class="viewcode-block" id="TaskMaster.set_mode"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.set_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set the global mode of the rejester system.</span>

<span class="sd">        This must be one of the constants :attr:`TERMINATE`,</span>
<span class="sd">        :attr:`RUN`, or :attr:`IDLE`.  :attr:`TERMINATE` instructs any</span>
<span class="sd">        running workers to do an orderly shutdown, completing current</span>
<span class="sd">        jobs then exiting.  :attr:`IDLE` instructs workers to stay</span>
<span class="sd">        running but not start new jobs.  :attr:`RUN` tells workers to</span>
<span class="sd">        do actual work.</span>

<span class="sd">        :param str mode: new rejester mode</span>
<span class="sd">        :raise rejester.exceptions.ProgrammerError: on invalid `mode`</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">TERMINATE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RUN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">IDLE</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;mode=</span><span class="si">%r</span><span class="s"> is not recognized&#39;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;modes&#39;</span><span class="p">,</span> <span class="s">&#39;mode&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;set mode to </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_mode"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_mode">[docs]</a>    <span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the global mode of the rejester system.</span>

<span class="sd">        :return: rejester mode, :attr:`IDLE` if unset</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;modes&#39;</span><span class="p">,</span> <span class="s">&#39;mode&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">IDLE</span>
</div>
<div class="viewcode-block" id="TaskMaster.idle_all_workers"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.idle_all_workers">[docs]</a>    <span class="k">def</span> <span class="nf">idle_all_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set the global mode to :attr:`IDLE` and wait for workers to stop.</span>

<span class="sd">        This can wait arbitrarily long before returning.  The worst</span>
<span class="sd">        case in &quot;normal&quot; usage involves waiting five minutes for a</span>
<span class="sd">        &quot;lost&quot; job to expire; a well-behaved but very-long-running job</span>
<span class="sd">        can extend its own lease further, and this function will not</span>
<span class="sd">        return until that job finishes (if ever).</span>

<span class="sd">        .. deprecated:: 0.4.5</span>
<span class="sd">            There isn&#39;t an obvious use case for this function, and its</span>
<span class="sd">            &quot;maybe wait forever for something out of my control&quot; nature</span>
<span class="sd">            makes it hard to use in real code.  Polling all of the work</span>
<span class="sd">            specs and their :meth:`num_pending` in application code if</span>
<span class="sd">            you really needed this operation would have the same</span>
<span class="sd">            semantics and database load.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IDLE</span><span class="p">)</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">num_pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">work_spec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">num_pending</span><span class="p">[</span><span class="n">work_spec_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_pending</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num_pending</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;waiting for pending work_units: </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">num_pending</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.mode_counts"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.mode_counts">[docs]</a>    <span class="k">def</span> <span class="nf">mode_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of workers in each mode.</span>

<span class="sd">        This returns a dictionary where the keys are mode constants</span>
<span class="sd">        and the values are a simple integer count of the number of</span>
<span class="sd">        workers in that mode.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">modes</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">RUN</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">IDLE</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TERMINATE</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">modes</span>
</div>
<div class="viewcode-block" id="TaskMaster.workers"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.workers">[docs]</a>    <span class="k">def</span> <span class="nf">workers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get a listing of all workers.</span>

<span class="sd">        This returns a dictionary mapping worker ID to the mode</span>
<span class="sd">        constant for their last observed mode.</span>

<span class="sd">        :param bool alive: if true (default), only include workers</span>
<span class="sd">          that have called :meth:`Worker.heartbeat` sufficiently recently</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">WORKER_OBSERVED_MODE</span><span class="p">,</span>
            <span class="n">priority_min</span><span class="o">=</span><span class="n">alive</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="ow">or</span> <span class="s">&#39;-inf&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_heartbeat"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_heartbeat">[docs]</a>    <span class="k">def</span> <span class="nf">get_heartbeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the last known state of some worker.</span>

<span class="sd">        If the worker never existed, or the worker&#39;s lifetime has</span>
<span class="sd">        passed without it heartbeating, this will return an empty</span>
<span class="sd">        dictionary.</span>

<span class="sd">        :param str worker_id: worker ID</span>
<span class="sd">        :return: dictionary of worker state, or empty dictionary</span>
<span class="sd">        :see: :meth:`Worker.heartbeat`</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">WORKER_STATE_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.dump"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Print the entire contents of this to debug log messages.</span>

<span class="sd">        This is really only intended for debugging.  It could produce</span>
<span class="sd">        a lot of data.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">work_spec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">)</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="n">sfx</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">sfx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[]</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">scan</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;spec {0} unit {1} available or pending&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">scan</span><span class="p">(</span><span class="n">_BLOCKED</span><span class="p">):</span>
                    <span class="n">blocked_on</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;spec {0} unit {1} blocked on {2!r}&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">blocked_on</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">scan</span><span class="p">(</span><span class="n">_FINISHED</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;spec {0} unit {1} finished&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">scan</span><span class="p">(</span><span class="n">_FAILED</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;spec {0} unit {1} failed&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskMaster.validate_work_spec"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.validate_work_spec">[docs]</a>    <span class="k">def</span> <span class="nf">validate_work_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">work_spec</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Check that `work_spec` is valid.</span>

<span class="sd">        It must at the very minimum contain a ``name`` and ``min_gb``.</span>

<span class="sd">        :raise rejester.exceptions.ProgrammerError: if it isn&#39;t valid</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="s">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">work_spec</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;work_spec lacks &quot;name&quot;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;min_gb&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">work_spec</span> <span class="ow">or</span> \
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;min_gb&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;work_spec[&quot;min_gb&quot;] must be a number&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_available"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_available">[docs]</a>    <span class="k">def</span> <span class="nf">num_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of available work units for some work spec.</span>

<span class="sd">        These are work units that could be returned by :meth:`get_work`:</span>
<span class="sd">        they are not complete, not currently executing, and not blocked</span>
<span class="sd">        on some other work unit.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                 <span class="n">priority_max</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_pending"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_pending">[docs]</a>    <span class="k">def</span> <span class="nf">num_pending</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of pending work units for some work spec.</span>

<span class="sd">        These are work units that some worker is currently working on</span>
<span class="sd">        (hopefully; it could include work units assigned to workers that</span>
<span class="sd">        died and that have not yet expired).</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                 <span class="n">priority_min</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_blocked"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_blocked">[docs]</a>    <span class="k">def</span> <span class="nf">num_blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of blocked work units for some work spec.</span>

<span class="sd">        These are work units that are the first parameter to</span>
<span class="sd">        :meth:`add_dependent_work_units` where the job they depend on</span>
<span class="sd">        has not yet completed.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_finished"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_finished">[docs]</a>    <span class="k">def</span> <span class="nf">num_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of finished work units for some work spec.</span>

<span class="sd">        These have completed successfully with :meth:`WorkUnit.finish`.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_failed"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_failed">[docs]</a>    <span class="k">def</span> <span class="nf">num_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the number of failed work units for some work spec.</span>

<span class="sd">        These have completed unsuccessfully with :meth:`WorkUnit.fail`.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.num_tasks"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.num_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">num_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the total number of work units for some work spec.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_finished</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">)</span> <span class="o">+</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">num_failed</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">)</span> <span class="o">+</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.status"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.status">[docs]</a>    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get a summary dictionary for some work spec.</span>

<span class="sd">        The keys are the strings :meth:`num_available`, :meth:`num_pending`,</span>
<span class="sd">        :meth:`num_blocked`, :meth:`num_finished`, :meth:`num_failed`,</span>
<span class="sd">        and :meth:`num_tasks`, and the values are the values returned</span>
<span class="sd">        from those functions.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">num_available</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_available</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="n">num_pending</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_pending</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="n">num_blocked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_blocked</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="n">num_finished</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finished</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="n">num_failed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_failed</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="n">num_tasks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_tasks</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">),</span>
            <span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_work_specs"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_work_specs">[docs]</a>    <span class="k">def</span> <span class="nf">list_work_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the list of [(work spec name, work spec), ...]</span>

<span class="sd">        The keys are the work spec names; the values are the actual</span>
<span class="sd">        work spec definitions.</span>

<span class="sd">        return [(spec name, spec), ...], next start value</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="TaskMaster.iter_work_specs"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.iter_work_specs">[docs]</a>    <span class="k">def</span> <span class="nf">iter_work_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        yield work spec dicts</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ws_list</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_work_specs</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name_spec</span> <span class="ow">in</span> <span class="n">ws_list</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">limit</span> <span class="o">-=</span> <span class="n">count</span>
            <span class="n">ws_list</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_work_specs</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_work_spec"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_work_spec">[docs]</a>    <span class="k">def</span> <span class="nf">get_work_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the dictionary defining some work spec.&#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">get_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get (key, value) pairs for work units.</span>

<span class="sd">        If `state` is not :const:`None`, then it should be one of</span>
<span class="sd">        the string state constants, and this function will return</span>
<span class="sd">        a list of pairs of work unit key and value for work units</span>
<span class="sd">        in that state.  If `start` is not :const:`None`, then this</span>
<span class="sd">        many work units are skipped; if `limit` is not :const:`None`</span>
<span class="sd">        then at most this many work units will be returned.</span>

<span class="sd">        If `state` is :const:`None` then all work units in all</span>
<span class="sd">        states will be returned.</span>

<span class="sd">        :param str work_spec_name: name of work spec to query</span>
<span class="sd">        :param str state: string state constant, or :const:`None`</span>
<span class="sd">          for all work units in all states</span>
<span class="sd">        :param int limit: maximum number of items to return</span>
<span class="sd">        :param int start: skip this many items before returning any</span>
<span class="sd">        :return: list of pairs of (work unit key, work unit data)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">work_unit_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;get_work_units(by work_unit_keys)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">AVAILABLE</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_available_work_units</span><span class="p">(</span>
                    <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PENDING</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_pending_work_units</span><span class="p">(</span>
                    <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">BLOCKED</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_blocked_work_units</span><span class="p">(</span>
                    <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">FINISHED</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_finished_work_units</span><span class="p">(</span>
                    <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">FAILED</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_failed_work_units</span><span class="p">(</span>
                    <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&quot;unknown state {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
        <span class="c"># TODO: correctly handle start/limit for the case where</span>
        <span class="c"># we&#39;re trying to list everything (unqualified)...this is</span>
        <span class="c"># actually kind of limited utility</span>
        <span class="n">work_units</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">work_units</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">))</span>
        <span class="n">work_units</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_blocked_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">))</span>
        <span class="n">work_units</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_finished_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">))</span>
        <span class="n">work_units</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_failed_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">work_units</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Only work units that have not been completed (&quot;available&quot; or</span>
<span class="sd">        &quot;pending&quot; work units) are included.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_available_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_available_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_available_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of available work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Only work units that have not been started, or units that were</span>
<span class="sd">        started but did not complete in a timely fashion, are</span>
<span class="sd">        included.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                    <span class="n">priority_max</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_pending_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_pending_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_pending_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of in-progress work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Units listed here should be worked on by some worker.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                    <span class="n">priority_min</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_blocked_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_blocked_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_blocked_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of blocked work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Work units included in this list are blocked because they were</span>
<span class="sd">        listed as the first work unit in</span>
<span class="sd">        :func:`add_dependent_work_units`, and the work unit(s) they</span>
<span class="sd">        depend on have not completed yet.  This function does not tell</span>
<span class="sd">        why work units are blocked, it merely returns the fact that</span>
<span class="sd">        they are.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_finished_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_finished_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_finished_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of finished work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Only work units that have been successfully completed are</span>
<span class="sd">        included.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.list_failed_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.list_failed_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">list_failed_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of failed work units for some work spec.</span>

<span class="sd">        The dictionary is from work unit name to work unit definiton.</span>
<span class="sd">        Only work units that have completed unsuccessfully are included.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_remove_some_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span>
                                <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">priority_min</span><span class="o">=</span><span class="s">&#39;-inf&#39;</span><span class="p">,</span>
                                <span class="n">priority_max</span><span class="o">=</span><span class="s">&#39;+inf&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some units from somewhere.&#39;&#39;&#39;</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">work_unit_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span>
                        <span class="n">priority_min</span><span class="o">=</span><span class="n">priority_min</span><span class="p">,</span> <span class="n">priority_max</span><span class="o">=</span><span class="n">priority_max</span><span class="p">,</span>
                        <span class="n">limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span> <span class="k">break</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># TODO: This needs to honor priority_min/priority_max,</span>
            <span class="c"># otherwise it gets the wrong answer for &quot;available&quot;/</span>
            <span class="c"># &quot;pending&quot; (it will get both states).</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span>
                                        <span class="o">*</span><span class="n">work_unit_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span>

<div class="viewcode-block" id="TaskMaster.del_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.del_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">del_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Delete work units from a work spec.</span>

<span class="sd">        The parameters are considered in order as follows:</span>

<span class="sd">        * If `all` is :const:`True`, then all work units in</span>
<span class="sd">          `work_spec_name` are deleted; otherwise</span>
<span class="sd">        * If `state` is not :const:`None`, then all work units</span>
<span class="sd">          in the named state are deleted; otherwise</span>
<span class="sd">        * If `work_unit_keys` are specified, then those specific</span>
<span class="sd">          work units are deleted; otherwise</span>
<span class="sd">        * Nothing is deleted.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_keys: if not :const:`None`, only delete</span>
<span class="sd">          these specific keys</span>
<span class="sd">        :param str state: only delete work units in this state</span>
<span class="sd">        :param bool all: if true, delete all work units</span>
<span class="sd">        :return: number of work units deleted</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">AVAILABLE</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_available_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PENDING</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_pending_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLOCKED</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_blocked_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">FAILED</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_failed_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">FINISHED</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_finished_work_units</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span>
</div>
<div class="viewcode-block" id="TaskMaster.clear"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Delete everything.</span>
<span class="sd">        Deletes all work units and all work specs.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">delete_namespace</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="TaskMaster.remove_available_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.remove_available_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">remove_available_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some work units in the available queue.</span>

<span class="sd">        If `work_unit_names` is :const:`None` (which must be passed</span>
<span class="sd">        explicitly), all available work units in `work_spec_name` are</span>
<span class="sd">        removed; otherwise only the specific named work units will be.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_names: names of the work units, or</span>
<span class="sd">          :const:`None` for all in `work_spec_name`</span>
<span class="sd">        :return: number of work units removed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_some_work_units</span><span class="p">(</span>
            <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span> <span class="n">priority_max</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="TaskMaster.remove_pending_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.remove_pending_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">remove_pending_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some work units in the pending list.</span>

<span class="sd">        If `work_unit_names` is :const:`None` (which must be passed</span>
<span class="sd">        explicitly), all pending work units in `work_spec_name` are</span>
<span class="sd">        removed; otherwise only the specific named work units will be.</span>

<span class="sd">        Note that this function has the potential to confuse workers</span>
<span class="sd">        if they are actually working on the work units in question.  If</span>
<span class="sd">        you have ensured that the workers are dead and you would be</span>
<span class="sd">        otherwise waiting for the leases to expire before calling</span>
<span class="sd">        :meth:`remove_available_work_units`, then this is a useful</span>
<span class="sd">        shortcut.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_names: names of the work units, or</span>
<span class="sd">          :const:`None` for all in `work_spec_name`</span>
<span class="sd">        :return: number of work units removed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_some_work_units</span><span class="p">(</span>
            <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span> <span class="n">priority_min</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="TaskMaster.remove_blocked_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.remove_blocked_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">remove_blocked_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some work units in the blocked list.</span>

<span class="sd">        If `work_unit_names` is :const:`None` (which must be passed</span>
<span class="sd">        explicitly), all pending work units in `work_spec_name` are</span>
<span class="sd">        removed; otherwise only the specific named work units will be.</span>

<span class="sd">        Note that none of the &quot;remove&quot; functions will restart blocked</span>
<span class="sd">        work units, so if you have called</span>
<span class="sd">        e.g. :meth:`remove_available_work_units` for a predecessor</span>
<span class="sd">        job, you may need to also call this method for its successor.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_names: names of the work units, or</span>
<span class="sd">          :const:`None` for all in `work_spec_name`</span>
<span class="sd">        :return: number of work units removed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_some_work_units</span><span class="p">(</span>
            <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">_BLOCKED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.remove_failed_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.remove_failed_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">remove_failed_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some failed work units.</span>

<span class="sd">        If `work_unit_names` is :const:`None` (which must be passed</span>
<span class="sd">        explicitly), all failed work units in `work_spec_name` are</span>
<span class="sd">        removed; otherwise only the specific named work units will be.</span>

<span class="sd">        Also consider :meth:`retry` to move failed work units back into</span>
<span class="sd">        the available queue.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_names: names of the work units, or</span>
<span class="sd">          :const:`None` for all in `work_spec_name`</span>
<span class="sd">        :return: number of work units removed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_some_work_units</span><span class="p">(</span>
            <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">_FAILED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.remove_finished_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.remove_finished_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">remove_finished_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove some finished work units.</span>

<span class="sd">        If `work_unit_names` is :const:`None` (which must be passed</span>
<span class="sd">        explicitly), all finished work units in `work_spec_name` are</span>
<span class="sd">        removed; otherwise only the specific named work units will be.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param list work_unit_names: names of the work units, or</span>
<span class="sd">          :const:`None` for all in `work_spec_name`</span>
<span class="sd">        :return: number of work units removed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_some_work_units</span><span class="p">(</span>
            <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_names</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">_FINISHED</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_work_unit_status"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_work_unit_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_work_unit_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get a high-level status for some work unit.</span>

<span class="sd">        The return value is a dictionary.  The only required key is</span>
<span class="sd">        ``status``, which could be any of:</span>

<span class="sd">        ``missing``</span>
<span class="sd">          The work unit does not exist anywhere</span>
<span class="sd">        ``available``</span>
<span class="sd">          The work unit is available for new workers; additional</span>
<span class="sd">          keys include ``expiration`` (may be 0)</span>
<span class="sd">        ``pending``</span>
<span class="sd">          The work unit is being worked on; additional keys include</span>
<span class="sd">          ``expiration`` and ``worker_id`` (usually)</span>
<span class="sd">        ``blocked``</span>
<span class="sd">          The work unit is waiting for some other work units to finish;</span>
<span class="sd">          additional keys include ``depends_on``</span>
<span class="sd">        ``finished``</span>
<span class="sd">          The work unit has completed</span>
<span class="sd">        ``failed``</span>
<span class="sd">          The work unit failed; additional keys include ``traceback``</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param str work_unit_name: name of the work unit</span>
<span class="sd">        :return: dictionary description of summary status</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="c"># In the available list?</span>
            <span class="p">(</span><span class="n">unit</span><span class="p">,</span><span class="n">priority</span><span class="p">)</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                          <span class="n">work_unit_key</span><span class="p">,</span> <span class="n">include_priority</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">priority</span> <span class="o">&lt;</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">():</span>
                    <span class="n">result</span><span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;available&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;pending&#39;</span>
                <span class="n">result</span><span class="p">[</span><span class="s">&#39;expiration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">priority</span>
                <span class="c"># ...is anyone working on it?</span>
                <span class="n">worker</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&quot;_locks&quot;</span><span class="p">,</span>
                                     <span class="n">work_unit_key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">worker</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="s">&#39;worker_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="c"># In the finished list?</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span>
                               <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span> <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;finished&#39;</span> <span class="p">}</span>

            <span class="c"># In the failed list?</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                               <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;failed&#39;</span> <span class="p">}</span>
                <span class="k">if</span> <span class="s">&#39;traceback&#39;</span> <span class="ow">in</span> <span class="n">unit</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="c"># In the blocked list?</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                               <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
                <span class="c"># This should always have *something*, right?</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span>
                                   <span class="n">work_unit_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;blocked&#39;</span><span class="p">,</span>
                           <span class="s">&#39;depends_on&#39;</span><span class="p">:</span> <span class="n">deps</span> <span class="p">}</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="p">{</span> <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;missing&#39;</span> <span class="p">}</span>
</div>
<div class="viewcode-block" id="TaskMaster.inspect_work_unit"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.inspect_work_unit">[docs]</a>    <span class="k">def</span> <span class="nf">inspect_work_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the data for some work unit.</span>

<span class="sd">        Returns the data for that work unit, or `None` if it really</span>
<span class="sd">        can&#39;t be found.</span>

<span class="sd">        :param str work_spec_name: name of the work spec</span>
<span class="sd">        :param str work_unit_key: name of the work unit</span>
<span class="sd">        :return: definition of the work unit, or `None`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">work_unit_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">work_unit_data</span><span class="p">:</span>
                <span class="n">work_unit_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">work_unit_data</span><span class="p">:</span>
                <span class="n">work_unit_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">work_unit_data</span><span class="p">:</span>
                <span class="n">work_unit_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">work_unit_data</span>
</div>
    <span class="k">def</span> <span class="nf">_inspect_work_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">work_unit_data</span>


<div class="viewcode-block" id="TaskMaster.reset_all"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.reset_all">[docs]</a>    <span class="k">def</span> <span class="nf">reset_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Restart a work spec.</span>

<span class="sd">        This calls :meth:`idle_all_workers`, then moves all finished</span>
<span class="sd">        jobs back into the available queue.</span>

<span class="sd">        .. deprecated:: 0.4.5</span>
<span class="sd">            See :meth:`idle_all_workers` for problems with that method.</span>
<span class="sd">            This also ignores failed jobs and work unit dependencies.</span>
<span class="sd">            In practice, whatever generated a set of work units</span>
<span class="sd">            initially can recreate them easily enough.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idle_all_workers</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">move_all</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span>
                             <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">reset_priorities</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.update_bundle"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.update_bundle">[docs]</a>    <span class="k">def</span> <span class="nf">update_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec</span><span class="p">,</span> <span class="n">work_units</span><span class="p">,</span> <span class="n">nice</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Load a work spec and some work units into the task list.</span>
<span class="sd">        </span>
<span class="sd">        update the work_spec and work_units.  Overwrites any existing</span>
<span class="sd">        work spec with the same ``work_spec[&#39;name&#39;]`` and similarly</span>
<span class="sd">        overwrites any WorkUnit with the same ``work_unit.key``</span>

<span class="sd">        :param dict work_spec: Work spec dictionary</span>
<span class="sd">        :param work_units: Keys are used as :attr:`WorkUnit.key`, values</span>
<span class="sd">          are used as :attr:`WorkUnit.data`</span>
<span class="sd">        :type work_units: dict of dict</span>
<span class="sd">        :param int nice: Niceness of `work_spec`, higher value is lower</span>
<span class="sd">          priority</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_work_spec</span><span class="p">(</span><span class="n">work_spec</span><span class="p">)</span>
        
        <span class="n">work_spec_name</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">,</span> <span class="p">{</span><span class="n">work_spec_name</span><span class="p">:</span> <span class="n">nice</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span>  <span class="p">{</span><span class="n">work_spec_name</span><span class="p">:</span> <span class="n">work_spec</span><span class="p">})</span>
            
            <span class="c">## redis chokes on lua scripts with </span>
            <span class="n">work_units</span> <span class="o">=</span> <span class="n">work_units</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">work_units</span><span class="p">),</span> <span class="n">window_size</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">re_acquire_lock</span><span class="p">()</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span> 
                               <span class="nb">dict</span><span class="p">(</span><span class="n">work_units</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="TaskMaster.set_work_spec"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.set_work_spec">[docs]</a>    <span class="k">def</span> <span class="nf">set_work_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        work_spec is a dict()</span>
<span class="sd">        work_spec[&#39;name&#39;] is used as work_spec_name in other API calls</span>
<span class="sd">        work_spec[&#39;nice&#39;] is used for prioritization, if set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_work_spec</span><span class="p">(</span><span class="n">work_spec</span><span class="p">)</span>

        <span class="n">nice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">work_spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;nice&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">work_spec_name</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">,</span> <span class="p">{</span><span class="n">work_spec_name</span><span class="p">:</span> <span class="n">nice</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span>  <span class="p">{</span><span class="n">work_spec_name</span><span class="p">:</span> <span class="n">work_spec</span><span class="p">})</span>
</div>
<div class="viewcode-block" id="TaskMaster.add_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.add_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">add_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key_vals</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        work_unit_key_vals list of (work_unit_key, work_unit_data)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">work_unit_key_vals</span><span class="p">),</span> <span class="n">window_size</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">re_acquire_lock</span><span class="p">()</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                               <span class="nb">dict</span><span class="p">(</span><span class="n">work_unit_key_vals</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="TaskMaster.add_dependent_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.add_dependent_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">add_dependent_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_unit</span><span class="p">,</span> <span class="n">depends_on</span><span class="p">,</span> <span class="n">hard</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add work units, where one prevents execution of the other.</span>

<span class="sd">        The two work units may be attached to different work specs,</span>
<span class="sd">        but both must be in this task master&#39;s namespace.  `work_unit`</span>
<span class="sd">        and `depends_on` are both tuples of (work spec name, work unit</span>
<span class="sd">        name, work unit dictionary).  The work specs must already</span>
<span class="sd">        exist; they may be created with :meth:`update_bundle` with</span>
<span class="sd">        an empty work unit dictionary.  If a work unit dictionary is</span>
<span class="sd">        provided with either work unit, then this defines that work</span>
<span class="sd">        unit, and any existing definition is replaced.  Either or both</span>
<span class="sd">        work unit dictionaries may be :const:`None`, in which case the</span>
<span class="sd">        work unit is not created if it does not already exist.  In</span>
<span class="sd">        this last case, the other work unit will be added if</span>
<span class="sd">        specified, but the dependency will not be added, and this</span>
<span class="sd">        function will return :const:`False`.  In all other cases, this</span>
<span class="sd">        dependency is added in addition to all existing dependencies</span>
<span class="sd">        on either or both work units, even if the work unit dictionary</span>
<span class="sd">        is replaced.</span>

<span class="sd">        `work_unit` will not be executed or reported as available via</span>
<span class="sd">        :meth:`get_work` until `depends_on` finishes execution.  If</span>
<span class="sd">        the `depends_on` task fails, then the `hard` parameter</span>
<span class="sd">        describes what happens: if `hard` is :const:`True` then</span>
<span class="sd">        `work_unit` will also fail, but if `hard` is :const:`False`</span>
<span class="sd">        then `work_unit` will be able to execute even if `depends_on`</span>
<span class="sd">        fails, it just must have completed some execution attempt.</span>

<span class="sd">        Calling this function with ``hard=True`` suggests an ordered</span>
<span class="sd">        sequence of tasks where the later task depends on the output</span>
<span class="sd">        of the earlier tasks.  Calling this function with</span>
<span class="sd">        ``hard=False`` suggests a cleanup task that must run after</span>
<span class="sd">        this task (and, likely, several others) are done, but doesn&#39;t</span>
<span class="sd">        specifically depend on its result being available.</span>

<span class="sd">        :param work_unit: &quot;Later&quot; work unit to execute</span>
<span class="sd">        :paramtype work_unit: tuple of (str,str,dict)</span>
<span class="sd">        :param depends_on: &quot;Earlier&quot; work unit to execute</span>
<span class="sd">        :paramtype depends_on: tuple of (str,str,dict)</span>
<span class="sd">        :param bool hard: if True, then `work_unit` automatically fails</span>
<span class="sd">          if `depends_on` fails</span>
<span class="sd">        :return: :const:`True`, unless one or both of the work units</span>
<span class="sd">          didn&#39;t exist and weren&#39;t specified, in which case, :const:`False`</span>
<span class="sd">        :raise rejester.exceptions.NoSuchWorkSpecError: if a work spec was</span>
<span class="sd">          named that doesn&#39;t exist</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># There&#39;s no good, not-confusing terminology here.</span>
        <span class="c"># I&#39;ll call work_unit &quot;later&quot; and depends_on &quot;earlier&quot;</span>
        <span class="c"># consistently, because that at least makes the time flow</span>
        <span class="c"># correct.</span>
        <span class="n">later_spec</span><span class="p">,</span> <span class="n">later_unit</span><span class="p">,</span> <span class="n">later_unitdef</span> <span class="o">=</span> <span class="n">work_unit</span>
        <span class="n">earlier_spec</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">,</span> <span class="n">earlier_unitdef</span> <span class="o">=</span> <span class="n">depends_on</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="c"># Bail if either work spec doesn&#39;t already exist</span>
            <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span> <span class="n">later_spec</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoSuchWorkSpecError</span><span class="p">(</span><span class="n">later_spec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span> <span class="n">earlier_spec</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoSuchWorkSpecError</span><span class="p">(</span><span class="n">earlier_spec</span><span class="p">)</span>
            
            <span class="c"># Cause both work units to exist (if possible)</span>
            <span class="c"># Note that if &quot;earlier&quot; is already finished, we may be</span>
            <span class="c"># able to make &quot;later&quot; available immediately</span>
            <span class="n">earlier_done</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">earlier_successful</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span><span class="p">,</span>
                               <span class="p">{</span> <span class="n">earlier_unit</span><span class="p">:</span> <span class="n">earlier_unitdef</span> <span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">earlier_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">earlier_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">earlier_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span> <span class="o">+</span> <span class="n">_FINISHED</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">earlier_done</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">earlier_successful</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">earlier_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">earlier_done</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="n">later_failed</span> <span class="o">=</span> <span class="n">earlier_done</span> <span class="ow">and</span> <span class="n">hard</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">earlier_successful</span>
            <span class="n">later_unblocked</span> <span class="o">=</span> <span class="p">((</span><span class="n">earlier_done</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">later_failed</span><span class="p">)</span> <span class="ow">or</span>
                               <span class="p">(</span><span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">later_failed</span><span class="p">:</span>
                <span class="n">later_destination</span> <span class="o">=</span> <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_FAILED</span>
            <span class="k">elif</span> <span class="n">later_unblocked</span><span class="p">:</span>
                <span class="n">later_destination</span> <span class="o">=</span> <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">later_destination</span> <span class="o">=</span> <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span>

            <span class="k">if</span> <span class="n">later_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">_FINISHED</span><span class="p">,</span> <span class="n">_FAILED</span><span class="p">,</span> <span class="n">_BLOCKED</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">suffix</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">later_destination</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">later_unit</span><span class="p">)</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">later_destination</span><span class="p">,</span>
                               <span class="p">{</span> <span class="n">later_unit</span><span class="p">:</span> <span class="n">later_unitdef</span> <span class="p">})</span>
            <span class="k">elif</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">later_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span><span class="p">,</span> <span class="n">later_unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">later_unitdef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span><span class="p">,</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span>
                        <span class="p">{</span> <span class="n">later_unit</span><span class="p">:</span> <span class="n">later_unitdef</span> <span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">later_unitdef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_BLOCKED</span><span class="p">,</span> <span class="n">later_unit</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">later_unitdef</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">earlier_unitdef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c"># Now both units exist and are in the right place;</span>
            <span class="c"># record the dependency</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span> <span class="o">+</span> <span class="n">_BLOCKS</span><span class="p">,</span>
                                 <span class="n">earlier_unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">blocks</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">later_spec</span><span class="p">,</span> <span class="n">later_unit</span><span class="p">,</span> <span class="n">hard</span><span class="p">])</span>
            <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">earlier_spec</span> <span class="o">+</span> <span class="n">_BLOCKS</span><span class="p">,</span>
                        <span class="n">earlier_unit</span><span class="p">,</span> <span class="n">blocks</span><span class="p">)</span>

            <span class="n">depends</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span>
                                  <span class="n">later_unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">depends</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">depends</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">depends</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">earlier_spec</span><span class="p">,</span> <span class="n">earlier_unit</span><span class="p">])</span>
            <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">later_spec</span> <span class="o">+</span> <span class="n">_DEPENDS</span><span class="p">,</span>
                        <span class="n">later_unit</span><span class="p">,</span> <span class="n">depends</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="TaskMaster.retry"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.retry">[docs]</a>    <span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="o">*</span><span class="n">work_unit_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Move failed work unit(s) back into the &quot;pending&quot; queue.</span>

<span class="sd">        The work unit will be available to execute immediately.  If</span>
<span class="sd">        other tasks had depended on it, those dependencies will not</span>
<span class="sd">        be recreated.</span>

<span class="sd">        :param str work_spec_name: name of the (existing) work spec</span>
<span class="sd">        :param str work_unit_names: name(s) of the (failed) work unit(s)</span>
<span class="sd">        :raise rejester.NoSuchWorkSpecError: if `work_spec_name` is</span>
<span class="sd">          invalid</span>
<span class="sd">        :raise rejester.NoSuchWorkUnitError: if `work_spec_name` is</span>
<span class="sd">          valid but any of the `work_unit_names` are not a failed work unit</span>
<span class="sd">        :raise rejester.LockError: if the registry lock could not be</span>
<span class="sd">          obtained</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="c"># This sequence is safe even if this system dies</span>
            <span class="n">units</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">work_unit_name</span> <span class="ow">in</span> <span class="n">work_unit_names</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                                   <span class="n">work_unit_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">NoSuchWorkSpecError</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">NoSuchWorkUnitError</span><span class="p">(</span><span class="n">work_unit_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="s">&#39;traceback&#39;</span> <span class="ow">in</span> <span class="n">unit</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">unit</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span>
                <span class="n">units</span><span class="p">[</span><span class="n">work_unit_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span>
            <span class="n">session</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="n">_FAILED</span><span class="p">,</span>
                         <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                         <span class="n">units</span><span class="p">,</span>
                         <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.nice"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.nice">[docs]</a>    <span class="k">def</span> <span class="nf">nice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">nice</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Change the priority of an existing work spec.&#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">work_spec_name</span><span class="o">=</span><span class="n">nice</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_work"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_work">[docs]</a>    <span class="k">def</span> <span class="nf">get_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">available_gb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lease_time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">work_spec_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_jobs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;obtain a WorkUnit instance based on available memory for the</span>
<span class="sd">        worker process.  </span>
<span class="sd">        </span>
<span class="sd">        :param worker_id: unique identifier string for a worker to</span>
<span class="sd">          which a WorkUnit will be assigned, if available.</span>
<span class="sd">        :param available_gb: number of gigabytes of RAM available to</span>
<span class="sd">          this worker</span>
<span class="sd">        :param lease_time: how many seconds to lease a WorkUnit</span>
<span class="sd">        :param int max_jobs: maximum number of work units to return (default 1)</span>
<span class="sd">        :param work_spec_names: limit to queue from one work_spec. NOT IMPLEMENTD. this implementation will return work from any work spec.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">available_gb</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProgrammerError</span><span class="p">(</span><span class="s">&#39;must specify available_gb&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">max_jobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_jobs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;redis rejester does not support max_jobs. ignoring and getting 1&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lease_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lease_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span>
        <span class="n">work_unit</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span> 
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
                <span class="c">## use the simple niceness algorithm described in</span>
                <span class="c">## http://en.wikipedia.org/wiki/Nice_(Unix)</span>
                <span class="c">## where each job gets a (20-niceness) share</span>
                <span class="n">nice_levels</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">NICE_LEVELS</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">nice</span> <span class="ow">in</span> <span class="n">nice_levels</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="n">nice</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="n">nice</span><span class="p">)</span>
                    <span class="n">nice</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="n">nice</span><span class="p">)</span>
                    <span class="n">nice</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">nice</span>
                    <span class="n">nice_levels</span><span class="p">[</span><span class="n">work_spec_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">nice</span>

                <span class="k">while</span> <span class="n">nice_levels</span><span class="p">:</span>
                    <span class="n">total_nice</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nice_levels</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">total_nice</span><span class="p">)</span>
                    <span class="n">work_spec_name</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">total_score</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">wsn</span><span class="p">,</span> <span class="n">nice</span> <span class="ow">in</span> <span class="n">nice_levels</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                        <span class="n">total_score</span> <span class="o">+=</span> <span class="n">nice</span>
                        <span class="k">if</span> <span class="n">total_score</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">:</span>
                            <span class="n">work_spec_name</span> <span class="o">=</span> <span class="n">wsn</span>
                            <span class="k">break</span>
                    <span class="k">assert</span> <span class="n">work_spec_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                    <span class="n">nice_levels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">work_spec_name</span><span class="p">)</span>
                    
                    <span class="c">## verify sufficient memory</span>
                    <span class="n">work_spec</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">available_gb</span> <span class="o">&lt;</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;min_gb&#39;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enough_memory</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Not enough memory to run work &#39;</span>
                                        <span class="s">&#39;spec </span><span class="si">%s</span><span class="s"> (need </span><span class="si">%.1f</span><span class="s"> GiB, have &#39;</span>
                                        <span class="s">&#39;</span><span class="si">%.1f</span><span class="s"> GiB) but running anyways&#39;</span><span class="p">,</span>
                                        <span class="n">work_spec_name</span><span class="p">,</span>
                                        <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;min_gb&#39;</span><span class="p">],</span>
                                        <span class="n">available_gb</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Not enough memory to run work &#39;</span>
                                        <span class="s">&#39;spec </span><span class="si">%s</span><span class="s"> (need </span><span class="si">%.1f</span><span class="s"> GiB, have &#39;</span>
                                        <span class="s">&#39;</span><span class="si">%.1f</span><span class="s"> GiB)&#39;</span><span class="p">,</span>
                                        <span class="n">work_spec_name</span><span class="p">,</span>
                                        <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;min_gb&#39;</span><span class="p">],</span>
                                        <span class="n">available_gb</span><span class="p">)</span>
                            <span class="k">continue</span>

                    <span class="c">## try to get a task</span>
                    <span class="n">wu_expires</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">lease_time</span>
                    <span class="n">_work_unit</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">getitem_reset</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                        <span class="n">priority_max</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                        <span class="n">new_priority</span><span class="o">=</span><span class="n">wu_expires</span><span class="p">,</span>
                        <span class="n">lock</span><span class="o">=</span><span class="n">worker_id</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">_work_unit</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;work unit </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">_work_unit</span><span class="p">)</span>
                        <span class="n">work_unit</span> <span class="o">=</span> <span class="n">WorkUnit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span>
                            <span class="n">_work_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_work_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">worker_id</span><span class="o">=</span><span class="n">worker_id</span><span class="p">,</span>
                            <span class="n">expires</span><span class="o">=</span><span class="n">wu_expires</span><span class="p">,</span>
                            <span class="n">default_lifetime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">break</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">LockError</span><span class="p">,</span> <span class="ne">EnvironmentError</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;took to long to get work&#39;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;get_work </span><span class="si">%r</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">work_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">work_unit</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_assigned_work_unit"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_assigned_work_unit">[docs]</a>    <span class="k">def</span> <span class="nf">get_assigned_work_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span>
                               <span class="n">work_unit_key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;get a specific WorkUnit that has already been assigned to a</span>
<span class="sd">        particular worker_id</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">assigned_work_unit_key</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assigned_work_unit_key</span> <span class="o">==</span> <span class="n">work_unit_key</span><span class="p">:</span>
                <span class="c"># raise LostLease instead of EnvironmentError, so</span>
                <span class="c"># users of TaskMaster can have a single type of</span>
                <span class="c"># expected exception, rather than two</span>
                <span class="k">raise</span> <span class="n">LostLease</span><span class="p">(</span>
                    <span class="s">&#39;assigned_work_unit_key=</span><span class="si">%r</span><span class="s"> != </span><span class="si">%r</span><span class="s">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">assigned_work_unit_key</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">))</span>
            <span class="c"># could trap EnvironmentError and raise LostLease instead</span>
            <span class="n">work_unit_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span>
                                         <span class="n">work_unit_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">WorkUnit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span>
                <span class="n">work_unit_key</span><span class="p">,</span> <span class="n">work_unit_data</span><span class="p">,</span>
                <span class="n">worker_id</span><span class="o">=</span><span class="n">worker_id</span><span class="p">,</span>
                <span class="n">default_lifetime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_lifetime</span><span class="p">,</span>
            <span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.get_child_work_units"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.get_child_work_units">[docs]</a>    <span class="k">def</span> <span class="nf">get_child_work_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get work units assigned to a worker&#39;s children.</span>

<span class="sd">        Returns a dictionary mapping worker ID to :class:`WorkUnit`.</span>
<span class="sd">        If a child exists but is idle, that worker ID will map to</span>
<span class="sd">        :const:`None`.  The work unit may already be expired or</span>
<span class="sd">        assigned to a different worker; this will be reflected in</span>
<span class="sd">        the returned :class:`WorkUnit`.</span>

<span class="sd">        This may write back to the underlying data store to clean up</span>
<span class="sd">        stale children that have not unregistered themselves but</span>
<span class="sd">        no longer exist in any form.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">all_children</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">WORKER_CHILDREN_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">)</span>
            <span class="c"># The data stored in Redis isn&#39;t actually conducive to</span>
            <span class="c"># this specific query; we will need to scan each work spec</span>
            <span class="c"># for each work unit</span>
            <span class="n">work_specs</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="n">WORK_SPECS</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">all_children</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="n">work_spec_name</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">work_specs</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                    <span class="n">work_unit_key</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">spec</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">work_unit_key</span><span class="p">:</span>
                        <span class="n">work_spec_name</span> <span class="o">=</span> <span class="n">spec</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">work_spec_name</span><span class="p">:</span>
                    <span class="n">assigned</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span> <span class="o">+</span> <span class="s">&#39;_locks&#39;</span><span class="p">,</span>
                        <span class="n">work_unit_key</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">WORK_UNITS_</span> <span class="o">+</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">,</span>
                        <span class="n">include_priority</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="c"># The work unit is probably already finished</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">WorkUnit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">,</span> <span class="n">work_spec_name</span><span class="p">,</span> <span class="n">work_unit_key</span><span class="p">,</span>
                            <span class="n">data</span><span class="p">,</span> <span class="n">expires</span><span class="o">=</span><span class="n">expires</span><span class="p">,</span> <span class="n">worker_id</span><span class="o">=</span><span class="n">assigned</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># The child isn&#39;t doing anything.  Does it still</span>
                    <span class="c"># exist?</span>
                    <span class="n">heartbeat</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WORKER_OBSERVED_MODE</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">heartbeat</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORKER_CHILDREN_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">,</span>
                                        <span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="TaskMaster.worker_register"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.worker_register">[docs]</a>    <span class="k">def</span> <span class="nf">worker_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lifetime</span><span class="o">=</span><span class="mi">6000</span><span class="p">,</span>
                        <span class="n">environment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># actually the same as heartbeat, just, &quot;hello, I&#39;m here&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_heartbeat</span><span class="p">(</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">lifetime</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span>
                              <span class="n">parent</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskMaster.worker_heartbeat"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.worker_heartbeat">[docs]</a>    <span class="k">def</span> <span class="nf">worker_heartbeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lifetime</span><span class="o">=</span><span class="mi">6000</span><span class="p">,</span>
                         <span class="n">environment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">environment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">environment</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">WORKER_OBSERVED_MODE</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">priority</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">lifetime</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORKER_STATE_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span>
                           <span class="n">expire</span><span class="o">=</span><span class="n">lifetime</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">session</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">WORKER_CHILDREN_</span> <span class="o">+</span> <span class="n">parent</span><span class="p">,</span>
                               <span class="p">{</span><span class="n">worker_id</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
</div>
<div class="viewcode-block" id="TaskMaster.worker_unregister"><a class="viewcode-back" href="../../sphinx-docs/rejester.html#rejester.TaskMaster.worker_unregister">[docs]</a>    <span class="k">def</span> <span class="nf">worker_unregister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="n">worker_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">WORKER_STATE_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">WORKER_CHILDREN_</span> <span class="o">+</span> <span class="n">worker_id</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORKER_OBSERVED_MODE</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">session</span><span class="o">.</span><span class="n">popmany</span><span class="p">(</span><span class="n">WORKER_CHILDREN_</span> <span class="o">+</span> <span class="n">parent</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">streamcorpus-pipeline 0.7.10.dev1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50390027-1', 'streamcorpus.org');
  ga('send', 'pageview');

</script>

  </body>
</html>