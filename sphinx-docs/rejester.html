<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. rejester — Redis-based distributed work manager &mdash; streamcorpus-pipeline 0.7.10.dev1 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.10.dev1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="streamcorpus-pipeline 0.7.10.dev1 documentation" href="../index.html" />
    <link rel="prev" title="6. kvlayer — database abstraction for key/value stores" href="kvlayer.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="kvlayer.html" title="6. kvlayer — database abstraction for key/value stores"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">streamcorpus-pipeline 0.7.10.dev1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-rejester">
<span id="rejester-redis-based-distributed-work-manager"></span><h1>7. <a class="reference internal" href="#module-rejester" title="rejester"><code class="xref py py-mod docutils literal"><span class="pre">rejester</span></code></a> &#8212; Redis-based distributed work manager<a class="headerlink" href="#module-rejester" title="Permalink to this headline">¶</a></h1>
<p>Redis-based distributed work manager.</p>
<p>Rejester is a distributed work manager, using the <a class="reference external" href="http://redis.io/">Redis</a> in-memory
database as shared state.  In typical use, some number of systems run
rejester <em>worker</em> processes, which query the central database to find
new work; anything that can reach the database can submit jobs.  The
standard rejester work system can also directly deliver work units to
programs without using the dedicated worker process.  For specialized
applications there is also a globally atomic string-based priority
queue.</p>
<p>To use a rejester-based application:</p>
<ol class="arabic simple">
<li>Create a YAML configuration file as described below.</li>
<li>Run <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">mode</span> <span class="pre">run</span></code> once on any system to enable rejester.</li>
<li>Run <strong class="command">rejester_worker</strong> on some number of systems with
identical copies of the configuration file.  These may be anywhere,
but must be able to reach the <a class="reference external" href="http://redis.io/">Redis</a> server.  Each will start as
many workers as the system has CPU cores.</li>
<li>Run some tool that generates rejester work units.  For instance,
the <strong class="command">streamcorpus_directory</strong> tool included in
<a class="reference external" href="https://github.com/trec-kba/streamcorpus-pipeline">streamcorpus-pipeline</a> generates work units to process text
files.</li>
<li>Run <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">summary</span></code> and other sub-commands of the
<strong class="command">rejester</strong> tool to get information about the job&#8217;s progress.</li>
<li>Run <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">mode</span> <span class="pre">terminate</span></code> to instruct all of the workers to
shut down.</li>
</ol>
<div class="section" id="module-rejester.run">
<span id="rejester-tool"></span><h2>7.1. <strong class="command">rejester</strong> tool<a class="headerlink" href="#module-rejester.run" title="Permalink to this headline">¶</a></h2>
<p>Command-line <a class="reference internal" href="#module-rejester" title="rejester"><code class="xref py py-mod docutils literal"><span class="pre">rejester</span></code></a> management tool.</p>
<p>This provides a centralized user interface to explore and affect
various parts of the <a class="reference internal" href="#module-rejester" title="rejester"><code class="xref py py-mod docutils literal"><span class="pre">rejester</span></code></a> system.  Of note, this is the
principal way to start a worker process to run jobs.  Typical use is:</p>
<ol class="arabic">
<li><p class="first">Set up a configuration file containing rejester configuration,
such as:</p>
<blockquote>
<div><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">rejester</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">app_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">rejester</span>
  <span class="l-Scalar-Plain">namespace</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mynamespace</span>
  <span class="l-Scalar-Plain">registry_addresses</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span> <span class="s">&quot;redis.example.com:6379&quot;</span> <span class="p-Indicator">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Run some process to generate rejester tasks.</p>
</li>
<li><p class="first">Copy the configuration files to other systems as required, and
run <code class="docutils literal"><span class="pre">rejester_worker</span> <span class="pre">-c</span> <span class="pre">config.yaml</span></code> to start workers.</p>
</li>
<li><p class="first">Run (anywhere, but only once) <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">-c</span> <span class="pre">config.yaml</span> <span class="pre">mode</span> <span class="pre">run</span></code>
to actually start execution.</p>
</li>
<li><p class="first">Wait for the work units to finish.</p>
</li>
<li><p class="first">Run (anywhere, but only once) <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">-c</span> <span class="pre">config.yaml</span> <span class="pre">mode</span> <span class="pre">terminate</span></code>
to ask the workers to shut down.</p>
</li>
</ol>
<p>In the configuration, <code class="docutils literal"><span class="pre">namespace</span></code> and <code class="docutils literal"><span class="pre">registry_addresses</span></code> are
required unless passed on the command line.  Additionally,
<code class="docutils literal"><span class="pre">registry_addresses</span></code> can be detected from environment variables
<code class="docutils literal"><span class="pre">REDIS_PORT_6379_TCP_ADDR</span></code> and <code class="docutils literal"><span class="pre">REDIS_PORT_6379_TCP_PORT</span></code>,
which will be set by <a class="reference external" href="http://www.docker.com/">Docker</a> if a
rejester program is run in a container that is <code class="docutils literal"><span class="pre">--link</span></code> connected
to another container with the name <code class="docutils literal"><span class="pre">redis</span></code>.</p>
<p>The <strong class="program">rejester</strong> tool supports the standard
<a class="reference internal" href="yakonfig.html#cmdoption-yakonfig--config"><code class="xref std std-option docutils literal"><span class="pre">--config</span></code></a>,
<a class="reference internal" href="yakonfig.html#cmdoption-yakonfig--dump-config"><code class="xref std std-option docutils literal"><span class="pre">--dump-config</span></code></a>,
<a class="reference internal" href="dblogger.html#cmdoption-dblogger--verbose"><code class="xref std std-option docutils literal"><span class="pre">--verbose</span></code></a>,
<a class="reference internal" href="dblogger.html#cmdoption-dblogger--quiet"><code class="xref std std-option docutils literal"><span class="pre">--quiet</span></code></a>, and
<a class="reference internal" href="dblogger.html#cmdoption-dblogger--debug"><code class="xref std std-option docutils literal"><span class="pre">--debug</span></code></a> options.  This, and any other tool
that integrates with <a class="reference internal" href="#module-rejester" title="rejester"><code class="xref py py-mod docutils literal"><span class="pre">rejester</span></code></a>, supports the following additional
options:</p>
<dl class="option">
<dt id="cmdoption-rejester--app-name">
<code class="descname">--app-name</code><code class="descclassname"> &lt;name&gt;</code><a class="headerlink" href="#cmdoption-rejester--app-name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Provide the application name for database access.  This is combined
with the namespace string.</p>
<dl class="option">
<dt id="cmdoption-rejester--namespace">
<code class="descname">--namespace</code><code class="descclassname"> &lt;name&gt;</code><a class="headerlink" href="#cmdoption-rejester--namespace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Provide the namespace name.  This is qualified by the application
name.  All work units and workers are associated with a single
namespace in a single application.</p>
<dl class="option">
<dt id="cmdoption-rejester--registry-address">
<code class="descname">--registry-address</code><code class="descclassname"> &lt;host:port&gt;</code><a class="headerlink" href="#cmdoption-rejester--registry-address" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Provide the location of a Redis server.</p>
<p>If no further options are given, start an interactive shell to monitor
and control <a class="reference internal" href="#module-rejester" title="rejester"><code class="xref py py-mod docutils literal"><span class="pre">rejester</span></code></a>.  Alternatively, a single command can be
given on the command line.  The tool provides the following commands:</p>
<dl class="describe">
<dt>
<code class="descname">summary</code></dt>
<dd><p>Print a tabular listing of all of the running work specs and
how many work units are in each state.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">load --work-spec file.yaml --work-units file2.json</code></dt>
<dd><p>Loads a set of work units.  The work spec (<code class="docutils literal"><span class="pre">-w</span></code>) and work units
(<code class="docutils literal"><span class="pre">-u</span></code>) must both be provided as external files.  The work spec
file is the YAML serialization of a work spec definition; see
<a class="reference internal" href="#rejester.TaskMaster" title="rejester.TaskMaster"><code class="xref py py-class docutils literal"><span class="pre">rejester.TaskMaster</span></code></a> for details of what this looks like.
The work unit file is a series of JSON records, one to a line,
each of which is a dictionary of a single <code class="docutils literal"><span class="pre">{&quot;key&quot;:</span> <span class="pre">{&quot;unit&quot;:</span>
<span class="pre">&quot;definition&quot;,</span> <span class="pre">&quot;dictionary&quot;:</span> <span class="pre">&quot;values&quot;}}</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">delete</code></dt>
<dd><p>Deletes the entire namespace.  Prompts for confirmation, unless
<code class="docutils literal"><span class="pre">-y</span></code> or <code class="docutils literal"><span class="pre">--yes</span></code> is given as an argument.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">work_specs</code></dt>
<dd><p>Prints out the names of all of the work specs.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">work_spec --work-spec-name name</code></dt>
<dd><p>Prints out the definition of a work spec, assuming it has already
been loaded.  The work spec name may be given with a
<code class="docutils literal"><span class="pre">--work-spec-name</span></code> or <code class="docutils literal"><span class="pre">-W</span></code> option; or, a <code class="docutils literal"><span class="pre">--work-spec</span></code> or
<code class="docutils literal"><span class="pre">-w</span></code> option may name a work spec file compatible with the
<code class="docutils literal"><span class="pre">load</span></code> command.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">status --work-spec-name name</code></dt>
<dd><p>Prints out a summary of the jobs in some work spec.  Provide the
work spec name the same way as for the <code class="docutils literal"><span class="pre">work_spec</span></code> command.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">work_units --work-spec-name name [--status status]</code></dt>
<dd><p>Prints out a listing of the work units that have not yet completed
for some work spec.  Provide the work spec name the same way as
for the <code class="docutils literal"><span class="pre">work_spec</span></code> command.  This includes the work units that
the <code class="docutils literal"><span class="pre">status</span></code> command would report as &#8220;available&#8221; or &#8220;pending&#8221;,
but not other statuses.  If <code class="docutils literal"><span class="pre">-s</span></code> or <code class="docutils literal"><span class="pre">--status</span></code> is given with
one of the status strings &#8220;available&#8221;, &#8220;pending&#8221;, &#8220;blocked&#8221;,
&#8220;failed&#8221;, or &#8220;finished&#8221;, only print work units with that status.
If <code class="docutils literal"><span class="pre">--details</span></code> is given as an argument, print the definition of
the work unit (and the traceback for failed work units) along with
its name.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">failed --work-spec-name name</code></dt>
<dd><p>Identical to <code class="docutils literal"><span class="pre">work_units</span> <span class="pre">--status</span> <span class="pre">failed</span></code>.  May be removed at
a future time.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">work_unit --work-spec-name name unitname</code></dt>
<dd><p>Prints out basic details for a work unit, in any state.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">retry --work-spec-name name [--all|unitname...]</code></dt>
<dd><p>Retry failed work units, removing their traceback and moving them
back to &#8220;available&#8221; status.  If <code class="docutils literal"><span class="pre">-a</span></code> or <code class="docutils literal"><span class="pre">--all</span></code> is given,
retry all failed work units; otherwise, only retry the specific
work units named on the command line.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">clear --work-spec-name name [--status status] [unitname...]</code></dt>
<dd><p>Remove work units from the system.  With no additional arguments,
remove all work units from the specified work spec.  If <code class="docutils literal"><span class="pre">-s</span></code> or
<code class="docutils literal"><span class="pre">--status</span></code> is given, remove only work units with this status;
see the description of the <cite>work_units</cite> subcommand for possible
values.  If any <code class="docutils literal"><span class="pre">unitname</span></code> values are given, only remove those
specific work units, provided they in fact have the specified
status.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">mode [idle|run|terminate]</code></dt>
<dd><p>With no arguments, print out the current rejester mode; otherwise
set it.  In &#8220;run&#8221; mode, workers will start new jobs as they become
available.  In &#8220;idle&#8221; mode, workers will not start new jobs but
also will continue to execute; if the mode is switched back to
&#8220;run&#8221; they will start running jobs again.  In &#8220;terminate&#8221; mode,
workers will stop execution as soon as they finish their running
jobs.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">run_one</code></dt>
<dd><p>Get a single task, and run it.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">global_lock [--purge]</code></dt>
<dd><p>The system maintains a global lock to make sequences of database
requests atomic, but if workers fail, the global lock can be leaked.
With no arguments, prints the worker ID that owns the global lock
and details that are known about it.  If <code class="docutils literal"><span class="pre">-p</span></code> or <code class="docutils literal"><span class="pre">--purge</span></code> is
given, clear out the lock if anybody holds it.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">workers</code></dt>
<dd><p>List all of the known workers.  With <code class="docutils literal"><span class="pre">--all</span></code> include workers
that haven&#8217;t checked in recently.  With <code class="docutils literal"><span class="pre">--details</span></code> include all
known details.</p>
</dd></dl>

</div>
<div class="section" id="module-rejester.run_multi_worker">
<span id="rejester-worker-tool"></span><h2>7.2. <strong class="command">rejester_worker</strong> tool<a class="headerlink" href="#module-rejester.run_multi_worker" title="Permalink to this headline">¶</a></h2>
<p>Command-line <code class="xref py py-mod docutils literal"><span class="pre">rejester_worker</span></code> tool for launching the
worker daemon.</p>
<dl class="option">
<dt id="cmdoption-rejester--pidfile">
<code class="descname">--pidfile</code><code class="descclassname"> /path/to/file.pid</code><a class="headerlink" href="#cmdoption-rejester--pidfile" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">--pidfile</span></code> is specified, the process ID of the worker is
written to the named file, which must be an absolute path.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-rejester--logpath">
<code class="descname">--logpath</code><code class="descclassname"> /path/to/file.log</code><a class="headerlink" href="#cmdoption-rejester--logpath" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>If <code class="docutils literal"><span class="pre">--logpath</span></code> is specified, log messages from the worker will
be written to the specified file, which again must be an absolute
path; this is in addition to any logging specified in the
configuration file.</div></blockquote>
<p>Start a worker as a background task.  The worker may be shut down by
globally switching to <code class="docutils literal"><span class="pre">mode</span> <span class="pre">terminate</span></code>, or by <code class="docutils literal"><span class="pre">kill</span> <span class="pre">$(cat</span>
<span class="pre">/path/to/file.pid)</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="configuration">
<h2>7.3. Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Rejester uses <a class="reference internal" href="yakonfig.html#module-yakonfig" title="yakonfig"><code class="xref py py-mod docutils literal"><span class="pre">yakonfig</span></code></a> for its configuration.  The relevant
section of the configuration file looks like:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">rejester</span><span class="p-Indicator">:</span>
  <span class="c1"># These two options are required</span>
  <span class="l-Scalar-Plain">registry_addresses</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span> <span class="s">&quot;redis.example.com:6379&quot;</span> <span class="p-Indicator">]</span>
  <span class="l-Scalar-Plain">namespace</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">rejester</span>

  <span class="c1"># The following are optional, defaults shown</span>
  <span class="l-Scalar-Plain">app_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">rejester</span>
  <span class="l-Scalar-Plain">default_lifetime</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">900</span>
  <span class="l-Scalar-Plain">enough_memory</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">false</span>
  <span class="l-Scalar-Plain">worker</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fork_worker</span>
</pre></div>
</div>
<p><cite>registry_addresses</cite> indicates the location of the <a class="reference external" href="http://redis.io/">Redis</a> server.
While this is a list, only the first value is used.  Also note that
YAML syntax requires quoting the <code class="docutils literal"><span class="pre">host:port</span></code> string, lest it be
interpreted as a dictionary.</p>
<p><cite>app_name</cite> and <cite>namespace</cite> identify the specific application in use.
Multiple applications can share the same <a class="reference external" href="http://redis.io/">Redis</a> server so long as
they have distinct namespace strings.  <cite>app_name</cite> is currently fixed
at <code class="docutils literal"><span class="pre">rejester</span></code> and setting a different value has no effect.</p>
<p><cite>default_lifetime</cite> indicates how long a job is allowed to run before
it must call <code class="xref py py-meth docutils literal"><span class="pre">rejester._task_master.WorkUnit.update()</span></code>.  If a
job runs beyond this timeout it will return from the &#8220;pending&#8221; list to
the &#8220;available&#8221; list, and another worker may start working on it.</p>
<p>When a worker requests a job, if the system does not have enough memory
to satisfy a given work spec&#8217;s <code class="docutils literal"><span class="pre">min_gb</span></code> request, that work spec is
skipped.  Setting <cite>enough_memory</cite> to true overrides this check.</p>
<p><cite>worker</cite> specifies the worker implementation to use in
<strong class="command">rejester_worker</strong>.  Valid options are <code class="docutils literal"><span class="pre">fork_worker</span></code> or
<code class="docutils literal"><span class="pre">multi_worker</span></code>.  <code class="docutils literal"><span class="pre">fork_worker</span></code> has additional configuration
options; see <a class="reference internal" href="#rejester.workers.ForkWorker" title="rejester.workers.ForkWorker"><code class="xref py py-class docutils literal"><span class="pre">ForkWorker</span></code></a> for details.
<code class="docutils literal"><span class="pre">multi_worker</span></code> is less stable and never allows jobs to time out, but
will start a set of jobs more quickly.</p>
</div>
<div class="section" id="task-system">
<h2>7.4. Task system<a class="headerlink" href="#task-system" title="Permalink to this headline">¶</a></h2>
<div class="section" id="core-api">
<h3>7.4.1. Core API<a class="headerlink" href="#core-api" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rejester.TaskMaster">
<em class="property">class </em><code class="descclassname">rejester.</code><code class="descname">TaskMaster</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Control object for the rejester task queue.</p>
<p>The task queue consists of a series of <em>work specs</em>, which include
configuration information, and each work spec has some number of
<em>work units</em> attached to it.  Both the work specs and work units
are defined as (non-empty) dictionaries.  The work spec must have
keys <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">min_gb</span></code>, but any other properties are permitted.
Conventionally <code class="docutils literal"><span class="pre">desc</span></code> contains a description of the job and
<code class="docutils literal"><span class="pre">config</span></code> contains the top-level global configuration.</p>
<p>There are three ways to use <a class="reference internal" href="#rejester.TaskMaster" title="rejester.TaskMaster"><code class="xref py py-class docutils literal"><span class="pre">TaskMaster</span></code></a>:</p>
<ol class="arabic simple">
<li>Create work specs and work units with <a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a>.
Directly call <a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">get_work()</span></code></a> to get work units back.  Based
on the information stored in the work spec and work unit
dictionaries, do the work manually, and call
<a class="reference internal" href="#rejester.WorkUnit.finish" title="rejester.WorkUnit.finish"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.finish()</span></code></a> or <a class="reference internal" href="#rejester.WorkUnit.fail" title="rejester.WorkUnit.fail"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.fail()</span></code></a> as
appropriate.</li>
<li>Create work specs and work units with <a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a>.
The work spec must contain three keys, <code class="docutils literal"><span class="pre">module</span></code> naming a Python
module, and <code class="docutils literal"><span class="pre">run_function</span></code> and <code class="docutils literal"><span class="pre">terminate_function</span></code> each
naming functions of a single parameter in that module.  Directly
call <a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">get_work()</span></code></a> to get work units back, then call their
<a class="reference internal" href="#rejester.WorkUnit.run" title="rejester.WorkUnit.run"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.run()</span></code></a> function to execute them.  See the basic
example in <a class="reference internal" href="#rejester.WorkUnit.fail" title="rejester.WorkUnit.fail"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.fail()</span></code></a>.</li>
<li>Create work specs and work units with <a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a>,
including the Python information.  Use one of the standard worker
implementations in <a class="reference internal" href="#module-rejester.workers" title="rejester.workers"><code class="xref py py-mod docutils literal"><span class="pre">rejester.workers</span></code></a> to actually run the
job.</li>
</ol>
<p>Most applications will use the third option, the standard worker
system.  In all three cases populating and executing jobs can
happen on different systems, or on multiple systems in parallel.
To use the standard worker system, create a Python module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">rejester_run</span><span class="p">(</span><span class="n">work_unit</span><span class="p">):</span>
    <span class="c"># Does the actual work for `work_unit`.</span>
    <span class="c"># Must be a top-level function in the module.</span>
    <span class="c"># The work unit will succeed if this returns normally,</span>
    <span class="c"># and will fail if this raises an exception.</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">rejester_terminate</span><span class="p">(</span><span class="n">work_unit</span><span class="p">):</span>
    <span class="c"># Called only if a signal terminates the worker.</span>
    <span class="c"># This usually does nothing, but could kill a known subprocess.</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The work spec would look something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">work_spec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;rejester_sample&#39;</span><span class="p">,</span>
    <span class="s">&#39;desc&#39;</span><span class="p">:</span> <span class="s">&#39;A sample rejester job.&#39;</span><span class="p">,</span>
    <span class="s">&#39;min_gb&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s">&#39;config&#39;</span><span class="p">:</span> <span class="n">yakonfig</span><span class="o">.</span><span class="n">get_global_config</span><span class="p">(),</span>
    <span class="s">&#39;module&#39;</span><span class="p">:</span> <span class="s">&#39;name.of.the.module.from.above&#39;</span><span class="p">,</span>
    <span class="s">&#39;run_function&#39;</span><span class="p">:</span> <span class="s">&#39;rejester_run&#39;</span><span class="p">,</span>
    <span class="s">&#39;terminate_function&#39;</span><span class="p">:</span> <span class="s">&#39;rejester_terminate&#39;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The work units can be any non-empty dictionaries that are
meaningful to the run function.  <a class="reference internal" href="#rejester.WorkUnit" title="rejester.WorkUnit"><code class="xref py py-class docutils literal"><span class="pre">WorkUnit</span></code></a> objects are
created with their <a class="reference internal" href="#rejester.WorkUnit.key" title="rejester.WorkUnit.key"><code class="xref py py-attr docutils literal"><span class="pre">key</span></code></a> and <code class="xref py py-attr docutils literal"><span class="pre">data</span></code>
fields set to individual keys and values from the parameter to
<a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a>.</p>
<p>A work unit can be in one of five states.  It is <em>available</em> if it
has been added to the queue but nobody is working on it.  It is
<em>pending</em> if somebody is currently working on it.  When they
finish, it will become either <em>finished</em> or <em>failed</em>.  If
dependencies are added between tasks using <cite>add_dependent_task()</cite>,
a task can also be <em>blocked</em>.</p>
<p>The general flow for a rejester application is to <a class="reference internal" href="#rejester.TaskMaster.set_mode" title="rejester.TaskMaster.set_mode"><code class="xref py py-meth docutils literal"><span class="pre">set_mode()</span></code></a>
to <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a>, then add work units using
<a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a>, and <a class="reference internal" href="#rejester.TaskMaster.set_mode" title="rejester.TaskMaster.set_mode"><code class="xref py py-meth docutils literal"><span class="pre">set_mode()</span></code></a> to <a class="reference internal" href="#rejester.TaskMaster.RUN" title="rejester.TaskMaster.RUN"><code class="xref py py-attr docutils literal"><span class="pre">RUN</span></code></a>.
<a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">get_work()</span></code></a> will return work units until all have been
consumed.  <a class="reference internal" href="#rejester.TaskMaster.set_mode" title="rejester.TaskMaster.set_mode"><code class="xref py py-meth docutils literal"><span class="pre">set_mode()</span></code></a> to <a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a> will instruct
workers to shut down.</p>
<p>This object keeps very little state locally and can safely be used
concurrently, including from multiple systems.  Correspondingly,
any settings here, including <a class="reference internal" href="#rejester.TaskMaster.set_mode" title="rejester.TaskMaster.set_mode"><code class="xref py py-meth docutils literal"><span class="pre">set_mode()</span></code></a>, are persistent even
beyond the end of the current process.</p>
<dl class="method">
<dt id="rejester.TaskMaster.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new task master.</p>
<p>This is a lightweight object, and it is safe to have multiple
objects concurrently accessing the same rejester system, even
on multiple machines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; Configuration for the task master, generally
the contents of the <code class="docutils literal"><span class="pre">rejester</span></code> block in the global configuration</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.config">
<code class="descname">config</code><em class="property"> = None</em><a class="headerlink" href="#rejester.TaskMaster.config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration for the task master</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.registry">
<code class="descname">registry</code><em class="property"> = None</em><a class="headerlink" href="#rejester.TaskMaster.registry" title="Permalink to this definition">¶</a></dt>
<dd><p>Mid-level Redis interface</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.worker_id">
<code class="descname">worker_id</code><em class="property"> = None</em><a class="headerlink" href="#rejester.TaskMaster.worker_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Worker ID, if this is tied to a worker</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.default_lifetime">
<code class="descname">default_lifetime</code><em class="property"> = None</em><a class="headerlink" href="#rejester.TaskMaster.default_lifetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Amount of time workers get between <a class="reference internal" href="#rejester.WorkUnit.update" title="rejester.WorkUnit.update"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.update()</span></code></a> calls</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.enough_memory">
<code class="descname">enough_memory</code><em class="property"> = None</em><a class="headerlink" href="#rejester.TaskMaster.enough_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Override available-memory checks</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.RUN">
<code class="descname">RUN</code><em class="property"> = 'RUN'</em><a class="headerlink" href="#rejester.TaskMaster.RUN" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode constant instructing workers to do work</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.IDLE">
<code class="descname">IDLE</code><em class="property"> = 'IDLE'</em><a class="headerlink" href="#rejester.TaskMaster.IDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode constant instructing workers to not start new work</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.TERMINATE">
<code class="descname">TERMINATE</code><em class="property"> = 'TERMINATE'</em><a class="headerlink" href="#rejester.TaskMaster.TERMINATE" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode constant instructing workers to shut down</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.AVAILABLE">
<code class="descname">AVAILABLE</code><em class="property"> = 1</em><a class="headerlink" href="#rejester.TaskMaster.AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.BLOCKED">
<code class="descname">BLOCKED</code><em class="property"> = 2</em><a class="headerlink" href="#rejester.TaskMaster.BLOCKED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.PENDING">
<code class="descname">PENDING</code><em class="property"> = 3</em><a class="headerlink" href="#rejester.TaskMaster.PENDING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.FINISHED">
<code class="descname">FINISHED</code><em class="property"> = 4</em><a class="headerlink" href="#rejester.TaskMaster.FINISHED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="rejester.TaskMaster.FAILED">
<code class="descname">FAILED</code><em class="property"> = 5</em><a class="headerlink" href="#rejester.TaskMaster.FAILED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.set_mode">
<code class="descname">set_mode</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.set_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global mode of the rejester system.</p>
<p>This must be one of the constants <a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a>,
<a class="reference internal" href="#rejester.TaskMaster.RUN" title="rejester.TaskMaster.RUN"><code class="xref py py-attr docutils literal"><span class="pre">RUN</span></code></a>, or <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a>.  <a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a> instructs any
running workers to do an orderly shutdown, completing current
jobs then exiting.  <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a> instructs workers to stay
running but not start new jobs.  <a class="reference internal" href="#rejester.TaskMaster.RUN" title="rejester.TaskMaster.RUN"><code class="xref py py-attr docutils literal"><span class="pre">RUN</span></code></a> tells workers to
do actual work.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; new rejester mode</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.ProgrammerError" title="rejester.exceptions.ProgrammerError">rejester.exceptions.ProgrammerError</a>:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">on invalid <cite>mode</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_mode">
<code class="descname">get_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the global mode of the rejester system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">rejester mode, <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a> if unset</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.idle_all_workers">
<code class="descname">idle_all_workers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.idle_all_workers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.idle_all_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global mode to <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a> and wait for workers to stop.</p>
<p>This can wait arbitrarily long before returning.  The worst
case in &#8220;normal&#8221; usage involves waiting five minutes for a
&#8220;lost&#8221; job to expire; a well-behaved but very-long-running job
can extend its own lease further, and this function will not
return until that job finishes (if ever).</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 0.4.5: </span>There isn&#8217;t an obvious use case for this function, and its
&#8220;maybe wait forever for something out of my control&#8221; nature
makes it hard to use in real code.  Polling all of the work
specs and their <a class="reference internal" href="#rejester.TaskMaster.num_pending" title="rejester.TaskMaster.num_pending"><code class="xref py py-meth docutils literal"><span class="pre">num_pending()</span></code></a> in application code if
you really needed this operation would have the same
semantics and database load.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.mode_counts">
<code class="descname">mode_counts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.mode_counts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.mode_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of workers in each mode.</p>
<p>This returns a dictionary where the keys are mode constants
and the values are a simple integer count of the number of
workers in that mode.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.workers">
<code class="descname">workers</code><span class="sig-paren">(</span><em>alive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.workers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a listing of all workers.</p>
<p>This returns a dictionary mapping worker ID to the mode
constant for their last observed mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>alive</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if true (default), only include workers
that have called <a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">Worker.heartbeat()</span></code></a> sufficiently recently</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_heartbeat">
<code class="descname">get_heartbeat</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_heartbeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_heartbeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last known state of some worker.</p>
<p>If the worker never existed, or the worker&#8217;s lifetime has
passed without it heartbeating, this will return an empty
dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_id</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; worker ID</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary of worker state, or empty dictionary</td>
</tr>
<tr class="field-odd field"><th class="field-name">See:</th><td class="field-body"><a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">Worker.heartbeat()</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the entire contents of this to debug log messages.</p>
<p>This is really only intended for debugging.  It could produce
a lot of data.</p>
</dd></dl>

<dl class="classmethod">
<dt id="rejester.TaskMaster.validate_work_spec">
<em class="property">classmethod </em><code class="descname">validate_work_spec</code><span class="sig-paren">(</span><em>work_spec</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.validate_work_spec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.validate_work_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that <cite>work_spec</cite> is valid.</p>
<p>It must at the very minimum contain a <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">min_gb</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.ProgrammerError" title="rejester.exceptions.ProgrammerError">rejester.exceptions.ProgrammerError</a>:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">if it isn&#8217;t valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_available">
<code class="descname">num_available</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of available work units for some work spec.</p>
<p>These are work units that could be returned by <a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">get_work()</span></code></a>:
they are not complete, not currently executing, and not blocked
on some other work unit.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_pending">
<code class="descname">num_pending</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_pending"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of pending work units for some work spec.</p>
<p>These are work units that some worker is currently working on
(hopefully; it could include work units assigned to workers that
died and that have not yet expired).</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_blocked">
<code class="descname">num_blocked</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of blocked work units for some work spec.</p>
<p>These are work units that are the first parameter to
<a class="reference internal" href="#rejester.TaskMaster.add_dependent_work_units" title="rejester.TaskMaster.add_dependent_work_units"><code class="xref py py-meth docutils literal"><span class="pre">add_dependent_work_units()</span></code></a> where the job they depend on
has not yet completed.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_finished">
<code class="descname">num_finished</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of finished work units for some work spec.</p>
<p>These have completed successfully with <a class="reference internal" href="#rejester.WorkUnit.finish" title="rejester.WorkUnit.finish"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.finish()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_failed">
<code class="descname">num_failed</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_failed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of failed work units for some work spec.</p>
<p>These have completed unsuccessfully with <a class="reference internal" href="#rejester.WorkUnit.fail" title="rejester.WorkUnit.fail"><code class="xref py py-meth docutils literal"><span class="pre">WorkUnit.fail()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.num_tasks">
<code class="descname">num_tasks</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.num_tasks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.num_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total number of work units for some work spec.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.status">
<code class="descname">status</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a summary dictionary for some work spec.</p>
<p>The keys are the strings <a class="reference internal" href="#rejester.TaskMaster.num_available" title="rejester.TaskMaster.num_available"><code class="xref py py-meth docutils literal"><span class="pre">num_available()</span></code></a>, <a class="reference internal" href="#rejester.TaskMaster.num_pending" title="rejester.TaskMaster.num_pending"><code class="xref py py-meth docutils literal"><span class="pre">num_pending()</span></code></a>,
<a class="reference internal" href="#rejester.TaskMaster.num_blocked" title="rejester.TaskMaster.num_blocked"><code class="xref py py-meth docutils literal"><span class="pre">num_blocked()</span></code></a>, <a class="reference internal" href="#rejester.TaskMaster.num_finished" title="rejester.TaskMaster.num_finished"><code class="xref py py-meth docutils literal"><span class="pre">num_finished()</span></code></a>, <a class="reference internal" href="#rejester.TaskMaster.num_failed" title="rejester.TaskMaster.num_failed"><code class="xref py py-meth docutils literal"><span class="pre">num_failed()</span></code></a>,
and <a class="reference internal" href="#rejester.TaskMaster.num_tasks" title="rejester.TaskMaster.num_tasks"><code class="xref py py-meth docutils literal"><span class="pre">num_tasks()</span></code></a>, and the values are the values returned
from those functions.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_work_specs">
<code class="descname">list_work_specs</code><span class="sig-paren">(</span><em>limit=None</em>, <em>start=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_work_specs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_work_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of [(work spec name, work spec), ...]</p>
<p>The keys are the work spec names; the values are the actual
work spec definitions.</p>
<p>return [(spec name, spec), ...], next start value</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.iter_work_specs">
<code class="descname">iter_work_specs</code><span class="sig-paren">(</span><em>limit=None</em>, <em>start=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.iter_work_specs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.iter_work_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>yield work spec dicts</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_work_spec">
<code class="descname">get_work_spec</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_work_spec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_work_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary defining some work spec.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_work_units">
<code class="descname">get_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_keys=None</em>, <em>state=None</em>, <em>limit=None</em>, <em>start=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get (key, value) pairs for work units.</p>
<p>If <cite>state</cite> is not <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, then it should be one of
the string state constants, and this function will return
a list of pairs of work unit key and value for work units
in that state.  If <cite>start</cite> is not <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, then this
many work units are skipped; if <cite>limit</cite> is not <code class="xref py py-const docutils literal"><span class="pre">None</span></code>
then at most this many work units will be returned.</p>
<p>If <cite>state</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> then all work units in all
states will be returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of work spec to query</li>
<li><strong>state</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; string state constant, or <code class="xref py py-const docutils literal"><span class="pre">None</span></code>
for all work units in all states</li>
<li><strong>limit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of items to return</li>
<li><strong>start</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; skip this many items before returning any</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of pairs of (work unit key, work unit data)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_work_units">
<code class="descname">list_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Only work units that have not been completed (&#8220;available&#8221; or
&#8220;pending&#8221; work units) are included.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_available_work_units">
<code class="descname">list_available_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_available_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_available_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of available work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Only work units that have not been started, or units that were
started but did not complete in a timely fashion, are
included.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_pending_work_units">
<code class="descname">list_pending_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_pending_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_pending_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of in-progress work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Units listed here should be worked on by some worker.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_blocked_work_units">
<code class="descname">list_blocked_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_blocked_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_blocked_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of blocked work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Work units included in this list are blocked because they were
listed as the first work unit in
<a class="reference internal" href="#rejester.TaskMaster.add_dependent_work_units" title="rejester.TaskMaster.add_dependent_work_units"><code class="xref py py-func docutils literal"><span class="pre">add_dependent_work_units()</span></code></a>, and the work unit(s) they
depend on have not completed yet.  This function does not tell
why work units are blocked, it merely returns the fact that
they are.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_finished_work_units">
<code class="descname">list_finished_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_finished_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_finished_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of finished work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Only work units that have been successfully completed are
included.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.list_failed_work_units">
<code class="descname">list_failed_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.list_failed_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.list_failed_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of failed work units for some work spec.</p>
<p>The dictionary is from work unit name to work unit definiton.
Only work units that have completed unsuccessfully are included.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.del_work_units">
<code class="descname">del_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_keys=None</em>, <em>state=None</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.del_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.del_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete work units from a work spec.</p>
<p>The parameters are considered in order as follows:</p>
<ul class="simple">
<li>If <cite>all</cite> is <code class="xref py py-const docutils literal"><span class="pre">True</span></code>, then all work units in
<cite>work_spec_name</cite> are deleted; otherwise</li>
<li>If <cite>state</cite> is not <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, then all work units
in the named state are deleted; otherwise</li>
<li>If <cite>work_unit_keys</cite> are specified, then those specific
work units are deleted; otherwise</li>
<li>Nothing is deleted.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_keys</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; if not <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, only delete
these specific keys</li>
<li><strong>state</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; only delete work units in this state</li>
<li><strong>all</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if true, delete all work units</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units deleted</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete everything.
Deletes all work units and all work specs.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.remove_available_work_units">
<code class="descname">remove_available_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.remove_available_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.remove_available_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove some work units in the available queue.</p>
<p>If <cite>work_unit_names</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (which must be passed
explicitly), all available work units in <cite>work_spec_name</cite> are
removed; otherwise only the specific named work units will be.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; names of the work units, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code> for all in <cite>work_spec_name</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.remove_pending_work_units">
<code class="descname">remove_pending_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.remove_pending_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.remove_pending_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove some work units in the pending list.</p>
<p>If <cite>work_unit_names</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (which must be passed
explicitly), all pending work units in <cite>work_spec_name</cite> are
removed; otherwise only the specific named work units will be.</p>
<p>Note that this function has the potential to confuse workers
if they are actually working on the work units in question.  If
you have ensured that the workers are dead and you would be
otherwise waiting for the leases to expire before calling
<a class="reference internal" href="#rejester.TaskMaster.remove_available_work_units" title="rejester.TaskMaster.remove_available_work_units"><code class="xref py py-meth docutils literal"><span class="pre">remove_available_work_units()</span></code></a>, then this is a useful
shortcut.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; names of the work units, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code> for all in <cite>work_spec_name</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.remove_blocked_work_units">
<code class="descname">remove_blocked_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.remove_blocked_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.remove_blocked_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove some work units in the blocked list.</p>
<p>If <cite>work_unit_names</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (which must be passed
explicitly), all pending work units in <cite>work_spec_name</cite> are
removed; otherwise only the specific named work units will be.</p>
<p>Note that none of the &#8220;remove&#8221; functions will restart blocked
work units, so if you have called
e.g. <a class="reference internal" href="#rejester.TaskMaster.remove_available_work_units" title="rejester.TaskMaster.remove_available_work_units"><code class="xref py py-meth docutils literal"><span class="pre">remove_available_work_units()</span></code></a> for a predecessor
job, you may need to also call this method for its successor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; names of the work units, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code> for all in <cite>work_spec_name</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.remove_failed_work_units">
<code class="descname">remove_failed_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.remove_failed_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.remove_failed_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove some failed work units.</p>
<p>If <cite>work_unit_names</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (which must be passed
explicitly), all failed work units in <cite>work_spec_name</cite> are
removed; otherwise only the specific named work units will be.</p>
<p>Also consider <a class="reference internal" href="#rejester.TaskMaster.retry" title="rejester.TaskMaster.retry"><code class="xref py py-meth docutils literal"><span class="pre">retry()</span></code></a> to move failed work units back into
the available queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; names of the work units, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code> for all in <cite>work_spec_name</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.remove_finished_work_units">
<code class="descname">remove_finished_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.remove_finished_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.remove_finished_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove some finished work units.</p>
<p>If <cite>work_unit_names</cite> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (which must be passed
explicitly), all finished work units in <cite>work_spec_name</cite> are
removed; otherwise only the specific named work units will be.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; names of the work units, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code> for all in <cite>work_spec_name</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of work units removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_work_unit_status">
<code class="descname">get_work_unit_status</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_work_unit_status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_work_unit_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a high-level status for some work unit.</p>
<p>The return value is a dictionary.  The only required key is
<code class="docutils literal"><span class="pre">status</span></code>, which could be any of:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">missing</span></code></dt>
<dd>The work unit does not exist anywhere</dd>
<dt><code class="docutils literal"><span class="pre">available</span></code></dt>
<dd>The work unit is available for new workers; additional
keys include <code class="docutils literal"><span class="pre">expiration</span></code> (may be 0)</dd>
<dt><code class="docutils literal"><span class="pre">pending</span></code></dt>
<dd>The work unit is being worked on; additional keys include
<code class="docutils literal"><span class="pre">expiration</span></code> and <code class="docutils literal"><span class="pre">worker_id</span></code> (usually)</dd>
<dt><code class="docutils literal"><span class="pre">blocked</span></code></dt>
<dd>The work unit is waiting for some other work units to finish;
additional keys include <code class="docutils literal"><span class="pre">depends_on</span></code></dd>
<dt><code class="docutils literal"><span class="pre">finished</span></code></dt>
<dd>The work unit has completed</dd>
<dt><code class="docutils literal"><span class="pre">failed</span></code></dt>
<dd>The work unit failed; additional keys include <code class="docutils literal"><span class="pre">traceback</span></code></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work unit</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dictionary description of summary status</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.inspect_work_unit">
<code class="descname">inspect_work_unit</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.inspect_work_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.inspect_work_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the data for some work unit.</p>
<p>Returns the data for that work unit, or <cite>None</cite> if it really
can&#8217;t be found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work spec</li>
<li><strong>work_unit_key</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the work unit</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">definition of the work unit, or <cite>None</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.reset_all">
<code class="descname">reset_all</code><span class="sig-paren">(</span><em>work_spec_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.reset_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.reset_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart a work spec.</p>
<p>This calls <a class="reference internal" href="#rejester.TaskMaster.idle_all_workers" title="rejester.TaskMaster.idle_all_workers"><code class="xref py py-meth docutils literal"><span class="pre">idle_all_workers()</span></code></a>, then moves all finished
jobs back into the available queue.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 0.4.5: </span>See <a class="reference internal" href="#rejester.TaskMaster.idle_all_workers" title="rejester.TaskMaster.idle_all_workers"><code class="xref py py-meth docutils literal"><span class="pre">idle_all_workers()</span></code></a> for problems with that method.
This also ignores failed jobs and work unit dependencies.
In practice, whatever generated a set of work units
initially can recreate them easily enough.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.update_bundle">
<code class="descname">update_bundle</code><span class="sig-paren">(</span><em>work_spec</em>, <em>work_units</em>, <em>nice=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.update_bundle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.update_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a work spec and some work units into the task list.</p>
<p>update the work_spec and work_units.  Overwrites any existing
work spec with the same <code class="docutils literal"><span class="pre">work_spec['name']</span></code> and similarly
overwrites any WorkUnit with the same <code class="docutils literal"><span class="pre">work_unit.key</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>work_spec</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; Work spec dictionary</li>
<li><strong>work_units</strong> (<em>dict of dict</em>) &#8211; Keys are used as <a class="reference internal" href="#rejester.WorkUnit.key" title="rejester.WorkUnit.key"><code class="xref py py-attr docutils literal"><span class="pre">WorkUnit.key</span></code></a>, values
are used as <code class="xref py py-attr docutils literal"><span class="pre">WorkUnit.data</span></code></li>
<li><strong>nice</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Niceness of <cite>work_spec</cite>, higher value is lower
priority</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.set_work_spec">
<code class="descname">set_work_spec</code><span class="sig-paren">(</span><em>work_spec</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.set_work_spec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.set_work_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>work_spec is a dict()
work_spec[&#8216;name&#8217;] is used as work_spec_name in other API calls
work_spec[&#8216;nice&#8217;] is used for prioritization, if set.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.add_work_units">
<code class="descname">add_work_units</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>work_unit_key_vals</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.add_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.add_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>work_unit_key_vals list of (work_unit_key, work_unit_data)</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.add_dependent_work_units">
<code class="descname">add_dependent_work_units</code><span class="sig-paren">(</span><em>work_unit</em>, <em>depends_on</em>, <em>hard=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.add_dependent_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.add_dependent_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Add work units, where one prevents execution of the other.</p>
<p>The two work units may be attached to different work specs,
but both must be in this task master&#8217;s namespace.  <cite>work_unit</cite>
and <cite>depends_on</cite> are both tuples of (work spec name, work unit
name, work unit dictionary).  The work specs must already
exist; they may be created with <a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">update_bundle()</span></code></a> with
an empty work unit dictionary.  If a work unit dictionary is
provided with either work unit, then this defines that work
unit, and any existing definition is replaced.  Either or both
work unit dictionaries may be <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, in which case the
work unit is not created if it does not already exist.  In
this last case, the other work unit will be added if
specified, but the dependency will not be added, and this
function will return <code class="xref py py-const docutils literal"><span class="pre">False</span></code>.  In all other cases, this
dependency is added in addition to all existing dependencies
on either or both work units, even if the work unit dictionary
is replaced.</p>
<p><cite>work_unit</cite> will not be executed or reported as available via
<a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">get_work()</span></code></a> until <cite>depends_on</cite> finishes execution.  If
the <cite>depends_on</cite> task fails, then the <cite>hard</cite> parameter
describes what happens: if <cite>hard</cite> is <code class="xref py py-const docutils literal"><span class="pre">True</span></code> then
<cite>work_unit</cite> will also fail, but if <cite>hard</cite> is <code class="xref py py-const docutils literal"><span class="pre">False</span></code>
then <cite>work_unit</cite> will be able to execute even if <cite>depends_on</cite>
fails, it just must have completed some execution attempt.</p>
<p>Calling this function with <code class="docutils literal"><span class="pre">hard=True</span></code> suggests an ordered
sequence of tasks where the later task depends on the output
of the earlier tasks.  Calling this function with
<code class="docutils literal"><span class="pre">hard=False</span></code> suggests a cleanup task that must run after
this task (and, likely, several others) are done, but doesn&#8217;t
specifically depend on its result being available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_unit</strong> (<em>tuple of (str,str,dict)</em>) &#8211; &#8220;Later&#8221; work unit to execute</li>
<li><strong>depends_on</strong> (<em>tuple of (str,str,dict)</em>) &#8211; &#8220;Earlier&#8221; work unit to execute</li>
<li><strong>hard</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if True, then <cite>work_unit</cite> automatically fails
if <cite>depends_on</cite> fails</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="xref py py-const docutils literal"><span class="pre">True</span></code>, unless one or both of the work units
didn&#8217;t exist and weren&#8217;t specified, in which case, <code class="xref py py-const docutils literal"><span class="pre">False</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.NoSuchWorkSpecError" title="rejester.exceptions.NoSuchWorkSpecError">rejester.exceptions.NoSuchWorkSpecError</a>:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first last">if a work spec was
named that doesn&#8217;t exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.retry">
<code class="descname">retry</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>*work_unit_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.retry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Move failed work unit(s) back into the &#8220;pending&#8221; queue.</p>
<p>The work unit will be available to execute immediately.  If
other tasks had depended on it, those dependencies will not
be recreated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the (existing) work spec</li>
<li><strong>work_unit_names</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name(s) of the (failed) work unit(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>rejester.NoSuchWorkSpecError</strong> &#8211; if <cite>work_spec_name</cite> is
invalid</li>
<li><strong>rejester.NoSuchWorkUnitError</strong> &#8211; if <cite>work_spec_name</cite> is
valid but any of the <cite>work_unit_names</cite> are not a failed work unit</li>
<li><strong>rejester.LockError</strong> &#8211; if the registry lock could not be
obtained</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.nice">
<code class="descname">nice</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>nice</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.nice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.nice" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the priority of an existing work spec.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_work">
<code class="descname">get_work</code><span class="sig-paren">(</span><em>worker_id</em>, <em>available_gb=None</em>, <em>lease_time=None</em>, <em>work_spec_names=None</em>, <em>max_jobs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_work" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a WorkUnit instance based on available memory for the
worker process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>worker_id</strong> &#8211; unique identifier string for a worker to
which a WorkUnit will be assigned, if available.</li>
<li><strong>available_gb</strong> &#8211; number of gigabytes of RAM available to
this worker</li>
<li><strong>lease_time</strong> &#8211; how many seconds to lease a WorkUnit</li>
<li><strong>max_jobs</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of work units to return (default 1)</li>
<li><strong>work_spec_names</strong> &#8211; limit to queue from one work_spec. NOT IMPLEMENTD. this implementation will return work from any work spec.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_assigned_work_unit">
<code class="descname">get_assigned_work_unit</code><span class="sig-paren">(</span><em>worker_id</em>, <em>work_spec_name</em>, <em>work_unit_key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_assigned_work_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_assigned_work_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>get a specific WorkUnit that has already been assigned to a
particular worker_id</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.get_child_work_units">
<code class="descname">get_child_work_units</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.get_child_work_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.get_child_work_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get work units assigned to a worker&#8217;s children.</p>
<p>Returns a dictionary mapping worker ID to <a class="reference internal" href="#rejester.WorkUnit" title="rejester.WorkUnit"><code class="xref py py-class docutils literal"><span class="pre">WorkUnit</span></code></a>.
If a child exists but is idle, that worker ID will map to
<code class="xref py py-const docutils literal"><span class="pre">None</span></code>.  The work unit may already be expired or
assigned to a different worker; this will be reflected in
the returned <a class="reference internal" href="#rejester.WorkUnit" title="rejester.WorkUnit"><code class="xref py py-class docutils literal"><span class="pre">WorkUnit</span></code></a>.</p>
<p>This may write back to the underlying data store to clean up
stale children that have not unregistered themselves but
no longer exist in any form.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.worker_register">
<code class="descname">worker_register</code><span class="sig-paren">(</span><em>worker_id</em>, <em>mode=None</em>, <em>lifetime=6000</em>, <em>environment=None</em>, <em>parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.worker_register"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.worker_register" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.worker_heartbeat">
<code class="descname">worker_heartbeat</code><span class="sig-paren">(</span><em>worker_id</em>, <em>mode=None</em>, <em>lifetime=6000</em>, <em>environment=None</em>, <em>parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.worker_heartbeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.worker_heartbeat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rejester.TaskMaster.worker_unregister">
<code class="descname">worker_unregister</code><span class="sig-paren">(</span><em>worker_id</em>, <em>parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#TaskMaster.worker_unregister"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.TaskMaster.worker_unregister" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="rejester.WorkUnit">
<em class="property">class </em><code class="descclassname">rejester.</code><code class="descname">WorkUnit</code><span class="sig-paren">(</span><em>registry</em>, <em>work_spec_name</em>, <em>key</em>, <em>data</em>, <em>worker_id=None</em>, <em>expires=None</em>, <em>default_lifetime=900</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A single unit of work being executed.</p>
<p>These are created by the rejester system; the standard worker
system will pass objects of this type to the named run function.
If some code calls:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">task_master</span><span class="o">.</span><span class="n">update_bundle</span><span class="p">({</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;work_spec_name&#39;</span><span class="p">,</span> <span class="o">...</span> <span class="p">},</span>
                          <span class="p">{</span> <span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="o">...</span> <span class="p">})</span>
</pre></div>
</div>
<p>Then when the work unit is executed, this object will have the
provided <a class="reference internal" href="#rejester.WorkUnit.work_spec_name" title="rejester.WorkUnit.work_spec_name"><code class="xref py py-attr docutils literal"><span class="pre">work_spec_name</span></code></a>, <a class="reference internal" href="#rejester.WorkUnit.key" title="rejester.WorkUnit.key"><code class="xref py py-attr docutils literal"><span class="pre">key</span></code></a>, and <code class="xref py py-attr docutils literal"><span class="pre">data</span></code>,
with remaining values being provided by the system.</p>
<p>In the standard worker system, the worker will call <a class="reference internal" href="#rejester.WorkUnit.finish" title="rejester.WorkUnit.finish"><code class="xref py py-meth docutils literal"><span class="pre">finish()</span></code></a>
or <a class="reference internal" href="#rejester.WorkUnit.fail" title="rejester.WorkUnit.fail"><code class="xref py py-meth docutils literal"><span class="pre">fail()</span></code></a> as appropriate.  The run function should examine
<a class="reference internal" href="#rejester.WorkUnit.spec" title="rejester.WorkUnit.spec"><code class="xref py py-attr docutils literal"><span class="pre">spec</span></code></a>, <a class="reference internal" href="#rejester.WorkUnit.key" title="rejester.WorkUnit.key"><code class="xref py py-attr docutils literal"><span class="pre">key</span></code></a>, and <code class="xref py py-attr docutils literal"><span class="pre">data</span></code> to figure out what to
do.</p>
<dl class="method">
<dt id="rejester.WorkUnit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>registry</em>, <em>work_spec_name</em>, <em>key</em>, <em>data</em>, <em>worker_id=None</em>, <em>expires=None</em>, <em>default_lifetime=900</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new work unit runtime data.</p>
<p>In most cases application code will not need to call this directly,
but should expect to be passed work units created by the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>registry</strong> (<a class="reference internal" href="#rejester.Registry" title="rejester.Registry"><code class="xref py py-class docutils literal"><span class="pre">rejester.Registry</span></code></a>) &#8211; Mid-level Redis interface</li>
<li><strong>work_spec_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Name of the work spec</li>
<li><strong>key</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Name of the work unit</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; Data provided for the work unit</li>
<li><strong>worker_id</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Worker doing this work unit</li>
<li><strong>expires</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Latest time this work unit can still be running</li>
<li><strong>default_lifetime</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Time <a class="reference internal" href="#rejester.WorkUnit.update" title="rejester.WorkUnit.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a> adds by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.worker_id">
<code class="descname">worker_id</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.worker_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Worker doing this work unit</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.registry">
<code class="descname">registry</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.registry" title="Permalink to this definition">¶</a></dt>
<dd><p>Mid-level Redis interface</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.work_spec_name">
<code class="descname">work_spec_name</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.work_spec_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the work spec</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.key">
<code class="descname">key</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the work unit</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.finished">
<code class="descname">finished</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this work unit called <a class="reference internal" href="#rejester.WorkUnit.finish" title="rejester.WorkUnit.finish"><code class="xref py py-meth docutils literal"><span class="pre">finish()</span></code></a>?</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.failed">
<code class="descname">failed</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this work unit called <a class="reference internal" href="#rejester.WorkUnit.fail" title="rejester.WorkUnit.fail"><code class="xref py py-meth docutils literal"><span class="pre">fail()</span></code></a>?</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.expires">
<code class="descname">expires</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.expires" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (as <a class="reference external" href="http://docs.python.org/library/time.html#time.time" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">time.time()</span></code></a>) when this work unit must finish</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.default_lifetime">
<code class="descname">default_lifetime</code><em class="property"> = None</em><a class="headerlink" href="#rejester.WorkUnit.default_lifetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Time <a class="reference internal" href="#rejester.WorkUnit.update" title="rejester.WorkUnit.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a> adds by default</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.spec">
<code class="descname">spec</code><a class="headerlink" href="#rejester.WorkUnit.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Actual work spec.</p>
<p>This is retrieved from the database on first use, and in some
cases a worker can be mildly more efficient if it avoids using
this.</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.WorkUnit.module">
<code class="descname">module</code><a class="headerlink" href="#rejester.WorkUnit.module" title="Permalink to this definition">¶</a></dt>
<dd><p>Python module to run the job.</p>
<p>This is used by <a class="reference internal" href="#module-rejester.run" title="rejester.run"><code class="xref py py-func docutils literal"><span class="pre">run()</span></code></a> and the standard worker system.
If the work spec contains keys <code class="docutils literal"><span class="pre">module</span></code>, <code class="docutils literal"><span class="pre">run_function</span></code>,
and <code class="docutils literal"><span class="pre">terminate_function</span></code>, then this contains the Python
module object named as <code class="docutils literal"><span class="pre">module</span></code>; otherwise this contains
<code class="xref py py-const docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.WorkUnit.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Actually runs the work unit.</p>
<p>This is called by the standard worker system, generally
once per work unit.  It requires the work spec to contain
keys <code class="docutils literal"><span class="pre">module</span></code>, <code class="docutils literal"><span class="pre">run_function</span></code>, and <code class="docutils literal"><span class="pre">terminate_function</span></code>.
It looks up <code class="docutils literal"><span class="pre">run_function</span></code> in <a class="reference internal" href="#rejester.WorkUnit.module" title="rejester.WorkUnit.module"><code class="xref py py-attr docutils literal"><span class="pre">module</span></code></a> and calls that
function with <code class="xref py py-const docutils literal"><span class="pre">self</span></code> as its only parameter.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.WorkUnit.terminate">
<code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.terminate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Kills the work unit.</p>
<p>This is called by the standard worker system, but only in
response to an operating system signal.  If the job does setup
such as creating a child process, its terminate function
should kill that child process.  More specifically, this
function requires the work spec to contain the keys
<code class="docutils literal"><span class="pre">module</span></code>, <code class="docutils literal"><span class="pre">run_function</span></code>, and <code class="docutils literal"><span class="pre">terminate_function</span></code>, and
calls <code class="docutils literal"><span class="pre">terminate_function</span></code> in <a class="reference internal" href="#rejester.WorkUnit.module" title="rejester.WorkUnit.module"><code class="xref py py-attr docutils literal"><span class="pre">module</span></code></a> containing
<code class="xref py py-const docutils literal"><span class="pre">self</span></code> as its only parameter.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.WorkUnit.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>lease_time=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh this task&#8217;s expiration time.</p>
<p>This tries to set the task&#8217;s expiration time to the current
time, plus <cite>lease_time</cite> seconds.  It requires the job to not
already be complete.  If <cite>lease_time</cite> is negative, makes the
job immediately be available for other workers to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lease_time</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; time to extend job lease beyond now</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.LostLease" title="rejester.exceptions.LostLease">rejester.exceptions.LostLease</a>:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">if the lease has already
expired</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.WorkUnit.finish">
<code class="descname">finish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.finish"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Move this work unit to a finished state.</p>
<p>In the standard worker system, the worker calls this on the job&#8217;s
behalf when <code class="xref py py-meth docutils literal"><span class="pre">run_function()</span></code> returns successfully.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.LostLease" title="rejester.exceptions.LostLease">rejester.exceptions.LostLease</a>:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">if the lease has already
expired</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.WorkUnit.fail">
<code class="descname">fail</code><span class="sig-paren">(</span><em>exc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#WorkUnit.fail"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.WorkUnit.fail" title="Permalink to this definition">¶</a></dt>
<dd><p>Move this work unit to a failed state.</p>
<p>In the standard worker system, the worker calls this on the job&#8217;s
behalf when <code class="xref py py-meth docutils literal"><span class="pre">run_function()</span></code> ends with any exception:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">work_unit</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="n">work_unit</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">work_unit</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>A <code class="docutils literal"><span class="pre">traceback</span></code> property is recorded with a formatted version
of <cite>exc</cite>, if any.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exc</strong> &#8211; Exception that caused the failure, or <code class="xref py py-const docutils literal"><span class="pre">None</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.LostLease" title="rejester.exceptions.LostLease">rejester.exceptions.LostLease</a>:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">if the lease has already
expired</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="workers">
<h3>7.4.2. Workers<a class="headerlink" href="#workers" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rejester.Worker">
<em class="property">class </em><code class="descclassname">rejester.</code><code class="descname">Worker</code><span class="sig-paren">(</span><em>config</em>, <em>task_master=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Process that runs rejester jobs.</p>
<p>Running a worker involves three steps: calling <a class="reference internal" href="#rejester.Worker.register" title="rejester.Worker.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a> to
get a <a class="reference internal" href="#rejester.Worker.worker_id" title="rejester.Worker.worker_id"><code class="xref py py-attr docutils literal"><span class="pre">worker_id</span></code></a> and record our presence in the data store;
calling <a class="reference internal" href="#module-rejester.run" title="rejester.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> to actually do work; and calling <a class="reference internal" href="#rejester.Worker.unregister" title="rejester.Worker.unregister"><code class="xref py py-meth docutils literal"><span class="pre">unregister()</span></code></a>
on clean exit.  The <a class="reference internal" href="#module-rejester.run" title="rejester.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> method should periodically call
<a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">heartbeat()</span></code></a> to update its state and get the current run mode.</p>
<p>..automethod:: __init__</p>
<dl class="attribute">
<dt id="rejester.Worker.config">
<code class="descname">config</code><em class="property"> = None</em><a class="headerlink" href="#rejester.Worker.config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration for the worker</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.Worker.task_master">
<code class="descname">task_master</code><em class="property"> = None</em><a class="headerlink" href="#rejester.Worker.task_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Task interface to talk to the data store</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.Worker.worker_id">
<code class="descname">worker_id</code><em class="property"> = None</em><a class="headerlink" href="#rejester.Worker.worker_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Worker ID, only valid after <a class="reference internal" href="#rejester.Worker.register" title="rejester.Worker.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.Worker.parent">
<code class="descname">parent</code><em class="property"> = None</em><a class="headerlink" href="#rejester.Worker.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent worker ID</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.Worker.lifetime">
<code class="descname">lifetime</code><em class="property"> = None</em><a class="headerlink" href="#rejester.Worker.lifetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Required maximum time between <a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">heartbeat()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="rejester.Worker.environment">
<code class="descname">environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker.environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker.environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Get raw data about this worker.</p>
<p>This is recorded in the <a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">heartbeat()</span></code></a> info, and can be
retrieved by <a class="reference internal" href="#rejester.TaskMaster.get_heartbeat" title="rejester.TaskMaster.get_heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">TaskMaster.get_heartbeat()</span></code></a>.  The dictionary
includes keys <code class="docutils literal"><span class="pre">worker_id</span></code>, <code class="docutils literal"><span class="pre">host</span></code>, <code class="docutils literal"><span class="pre">fqdn</span></code>, <code class="docutils literal"><span class="pre">version</span></code>,
<code class="docutils literal"><span class="pre">working_set</span></code>, and <code class="docutils literal"><span class="pre">memory</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.Worker.register">
<code class="descname">register</code><span class="sig-paren">(</span><em>parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker.register"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Record the availability of this worker and get a unique identifer.</p>
<p>This sets <a class="reference internal" href="#rejester.Worker.worker_id" title="rejester.Worker.worker_id"><code class="xref py py-attr docutils literal"><span class="pre">worker_id</span></code></a> and calls <a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-meth docutils literal"><span class="pre">heartbeat()</span></code></a>.  This
cannot be called multiple times without calling
<a class="reference internal" href="#rejester.Worker.unregister" title="rejester.Worker.unregister"><code class="xref py py-meth docutils literal"><span class="pre">unregister()</span></code></a> in between.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.Worker.unregister">
<code class="descname">unregister</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker.unregister"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker.unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this worker from the list of available workers.</p>
<p>This requires the worker to already have been <a class="reference internal" href="#rejester.Worker.register" title="rejester.Worker.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.Worker.heartbeat">
<code class="descname">heartbeat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker.heartbeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker.heartbeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Record the current worker state in the registry.</p>
<p>This records the worker&#8217;s current mode, plus the contents of
<a class="reference internal" href="#rejester.Worker.environment" title="rejester.Worker.environment"><code class="xref py py-meth docutils literal"><span class="pre">environment()</span></code></a>, in the data store for inspection by others.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns mode:</th><td class="field-body">Current mode, as <a class="reference internal" href="#rejester.TaskMaster.get_mode" title="rejester.TaskMaster.get_mode"><code class="xref py py-meth docutils literal"><span class="pre">TaskMaster.get_mode()</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Worker.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_task_master.html#Worker.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Worker.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run some number of jobs.</p>
<p><a class="reference internal" href="#rejester.Worker.register" title="rejester.Worker.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a> must have already been called.  This is
expected to get jobs using <a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">TaskMaster.get_work()</span></code></a> with
this worker&#8217;s <a class="reference internal" href="#rejester.Worker.worker_id" title="rejester.Worker.worker_id"><code class="xref py py-attr docutils literal"><span class="pre">worker_id</span></code></a>.  Depending on the semantics
of the actual implementing class this may run one job, run
jobs as long as the worker&#8217;s mode is <a class="reference internal" href="#rejester.TaskMaster.RUN" title="rejester.TaskMaster.RUN"><code class="xref py py-attr docutils literal"><span class="pre">RUN</span></code></a>,
or any other combination.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-rejester.workers"></span><p>Rejester workers.</p>
<p>The standard worker infrastructure in the classes below calls
<a class="reference internal" href="#rejester.WorkUnit.run" title="rejester.WorkUnit.run"><code class="xref py py-meth docutils literal"><span class="pre">rejester.WorkUnit.run()</span></code></a> on individual work units as they become
available.  In normal use, a caller will use
<a class="reference internal" href="#rejester.TaskMaster.update_bundle" title="rejester.TaskMaster.update_bundle"><code class="xref py py-meth docutils literal"><span class="pre">rejester.TaskMaster.update_bundle()</span></code></a> to submit jobs, then expect
an external caller to run <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">run_worker</span></code>, which will create a
<a class="reference internal" href="#rejester.workers.MultiWorker" title="rejester.workers.MultiWorker"><code class="xref py py-class docutils literal"><span class="pre">MultiWorker</span></code></a> object that runs those jobs.</p>
<p>Other implementation strategies are definitely possible.  The
<a class="reference internal" href="#rejester.workers.SingleWorker" title="rejester.workers.SingleWorker"><code class="xref py py-class docutils literal"><span class="pre">SingleWorker</span></code></a> class here will run exactly one job when
invoked.  It is also possible for a program that intends to do some
work, possibly even in parallel, but wants to depend on rejester for
queueing, to call <a class="reference internal" href="#rejester.TaskMaster.get_work" title="rejester.TaskMaster.get_work"><code class="xref py py-meth docutils literal"><span class="pre">rejester.TaskMaster.get_work()</span></code></a> itself and do
work based on whatever information is in the work spec; that would not
use this worker infrastructure at all.</p>
<dl class="class">
<dt id="rejester.workers.SingleWorker">
<em class="property">class </em><code class="descclassname">rejester.workers.</code><code class="descname">SingleWorker</code><span class="sig-paren">(</span><em>config</em>, <em>task_master=None</em>, <em>work_spec_names=None</em>, <em>max_jobs=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#SingleWorker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.SingleWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._task_master.Worker</span></code></p>
<p>Worker that runs exactly one job when called.</p>
<p>This is used by the <code class="xref py py-meth docutils literal"><span class="pre">rejester.run.Manager.do_run_one()</span></code>
command to run a single job; that just calls <a class="reference internal" href="#rejester.workers.SingleWorker.run" title="rejester.workers.SingleWorker.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>.  This
is also invoked as the child process by <a class="reference internal" href="#rejester.workers.ForkWorker" title="rejester.workers.ForkWorker"><code class="xref py py-class docutils literal"><span class="pre">ForkWorker</span></code></a>,
which calls <a class="reference internal" href="#rejester.workers.SingleWorker.as_child" title="rejester.workers.SingleWorker.as_child"><code class="xref py py-meth docutils literal"><span class="pre">as_child()</span></code></a>.</p>
<dl class="method">
<dt id="rejester.workers.SingleWorker.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>set_title=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#SingleWorker.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.SingleWorker.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Do some work.</p>
<p>The standard implementation here calls <a class="reference internal" href="#rejester.workers.SingleWorker.run_one" title="rejester.workers.SingleWorker.run_one"><code class="xref py py-meth docutils literal"><span class="pre">run_one()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>set_title</strong> &#8211; if true, set the process&#8217;s title with the
work unit name</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="xref py py-const docutils literal"><span class="pre">True</span></code> if there was a job (even if it failed)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.SingleWorker.run_one">
<code class="descname">run_one</code><span class="sig-paren">(</span><em>set_title=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#SingleWorker.run_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.SingleWorker.run_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Get exactly one job, run it, and return.</p>
<p>Does nothing (but returns <code class="xref py py-const docutils literal"><span class="pre">False</span></code>) if there is no work
to do.  Ignores the global mode; this will do work even
if <a class="reference internal" href="#rejester.TaskMaster.get_mode" title="rejester.TaskMaster.get_mode"><code class="xref py py-func docutils literal"><span class="pre">rejester.TaskMaster.get_mode()</span></code></a> returns
<a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>set_title</strong> &#8211; if true, set the process&#8217;s title with the
work unit name</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="xref py py-const docutils literal"><span class="pre">True</span></code> if there was a job (even if it failed)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="rejester.workers.SingleWorker.EXIT_SUCCESS">
<code class="descname">EXIT_SUCCESS</code><em class="property"> = 0</em><a class="headerlink" href="#rejester.workers.SingleWorker.EXIT_SUCCESS" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit code from <a class="reference internal" href="#rejester.workers.SingleWorker.as_child" title="rejester.workers.SingleWorker.as_child"><code class="xref py py-meth docutils literal"><span class="pre">as_child()</span></code></a> if it ran a work unit (maybe
unsuccessfully).</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.workers.SingleWorker.EXIT_EXCEPTION">
<code class="descname">EXIT_EXCEPTION</code><em class="property"> = 1</em><a class="headerlink" href="#rejester.workers.SingleWorker.EXIT_EXCEPTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit code from <a class="reference internal" href="#rejester.workers.SingleWorker.as_child" title="rejester.workers.SingleWorker.as_child"><code class="xref py py-meth docutils literal"><span class="pre">as_child()</span></code></a> if there was a failure getting
the work unit.</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.workers.SingleWorker.EXIT_BORED">
<code class="descname">EXIT_BORED</code><em class="property"> = 2</em><a class="headerlink" href="#rejester.workers.SingleWorker.EXIT_BORED" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit code from <a class="reference internal" href="#rejester.workers.SingleWorker.as_child" title="rejester.workers.SingleWorker.as_child"><code class="xref py py-meth docutils literal"><span class="pre">as_child()</span></code></a> if there was no work to do.</p>
</dd></dl>

<dl class="classmethod">
<dt id="rejester.workers.SingleWorker.as_child">
<em class="property">classmethod </em><code class="descname">as_child</code><span class="sig-paren">(</span><em>global_config</em>, <em>parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#SingleWorker.as_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.SingleWorker.as_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a single job in a child process.</p>
<p>This method never returns; it always calls <a class="reference external" href="http://docs.python.org/library/sys.html#sys.exit" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a>
with an error code that says what it did.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rejester.workers.MultiWorker">
<em class="property">class </em><code class="descclassname">rejester.workers.</code><code class="descname">MultiWorker</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#MultiWorker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.MultiWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._task_master.Worker</span></code></p>
<p>Parent worker that runs multiple jobs continuously.</p>
<p>This uses <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> to run one child
<a class="reference internal" href="#rejester.workers.HeadlessWorker" title="rejester.workers.HeadlessWorker"><code class="xref py py-class docutils literal"><span class="pre">HeadlessWorker</span></code></a> per core on the system, and averages
system memory to report <cite>available_gb</cite>.  This class manages the
<a class="reference internal" href="#rejester.TaskMaster" title="rejester.TaskMaster"><code class="xref py py-class docutils literal"><span class="pre">TaskMaster</span></code></a> interactions and sends
<a class="reference internal" href="#rejester.WorkUnit" title="rejester.WorkUnit"><code class="xref py py-class docutils literal"><span class="pre">WorkUnit</span></code></a> instances to its managed child
processes.</p>
<p>This class is normally invoked from the command line by
running <code class="docutils literal"><span class="pre">rejester</span> <span class="pre">run_worker</span></code>, which runs this class as a
daemon process.</p>
<p>Instances of this class, running across many machines in a
cluster, are controlled by <a class="reference internal" href="#rejester.TaskMaster.get_mode" title="rejester.TaskMaster.get_mode"><code class="xref py py-meth docutils literal"><span class="pre">rejester.TaskMaster.get_mode()</span></code></a>.
The <a class="reference internal" href="#rejester.workers.MultiWorker.run" title="rejester.workers.MultiWorker.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> method will exit if the current mode is
<a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a>.  If the mode is
<a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a> then the worker will stay
running but will not start new jobs.  New jobs will be started
only when the mode becomes <a class="reference internal" href="#rejester.TaskMaster.RUN" title="rejester.TaskMaster.RUN"><code class="xref py py-attr docutils literal"><span class="pre">RUN</span></code></a>.  The
system defaults to <a class="reference internal" href="#rejester.TaskMaster.IDLE" title="rejester.TaskMaster.IDLE"><code class="xref py py-attr docutils literal"><span class="pre">IDLE</span></code></a> state, but if
workers exit immediately, it may be because the mode has been left
at <a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a> from a previous
execution.</p>
<p>If <cite>tasks_per_cpu</cite> is set in the configuration block for rejester,
then that many child process will be launched for each CPU on the
machine.</p>
<dl class="method">
<dt id="rejester.workers.MultiWorker.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#MultiWorker.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.MultiWorker.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch and dispatch jobs as long as the system is running.</p>
<p>This periodically checks the <a class="reference internal" href="#rejester.TaskMaster" title="rejester.TaskMaster"><code class="xref py py-class docutils literal"><span class="pre">rejester.TaskMaster</span></code></a> mode
and asks it for more work.  It will normally run forever in a
loop until the mode becomes
<a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-attr docutils literal"><span class="pre">TERMINATE</span></code></a>, at which point it
waits for all outstanding jobs to finish and exits.</p>
<p>This will <a class="reference internal" href="#rejester.Worker.heartbeat" title="rejester.Worker.heartbeat"><code class="xref py py-func docutils literal"><span class="pre">heartbeat()</span></code></a> and check for new
work whenever a job finishes, or otherwise on a random
interval between 1 and 5 seconds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rejester.workers.HeadlessWorker">
<em class="property">class </em><code class="descclassname">rejester.workers.</code><code class="descname">HeadlessWorker</code><span class="sig-paren">(</span><em>config</em>, <em>worker_id</em>, <em>work_spec_name</em>, <em>work_unit_key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#HeadlessWorker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.HeadlessWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._task_master.Worker</span></code></p>
<p>Child worker to do work under <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a>.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> method expects to run a single
<a class="reference internal" href="#rejester.WorkUnit" title="rejester.WorkUnit"><code class="xref py py-class docutils literal"><span class="pre">WorkUnit</span></code></a>, which it will receive from its
parent <a class="reference internal" href="#rejester.workers.MultiWorker" title="rejester.workers.MultiWorker"><code class="xref py py-class docutils literal"><span class="pre">MultiWorker</span></code></a>.  This class expects to be the only
thing run in a <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> child process.</p>
</dd></dl>

<dl class="class">
<dt id="rejester.workers.ForkWorker">
<em class="property">class </em><code class="descclassname">rejester.workers.</code><code class="descname">ForkWorker</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._task_master.Worker</span></code></p>
<p>Parent worker that runs multiple jobs concurrently.</p>
<p>This manages a series of child processes, each of which runs
a <a class="reference internal" href="#rejester.workers.SingleWorker" title="rejester.workers.SingleWorker"><code class="xref py py-class docutils literal"><span class="pre">SingleWorker</span></code></a>.  It runs as long as the global rejester
state is not <a class="reference internal" href="#rejester.TaskMaster.TERMINATE" title="rejester.TaskMaster.TERMINATE"><code class="xref py py-class docutils literal"><span class="pre">rejester.TaskMaster.TERMINATE</span></code></a>.</p>
<p>This takes some additional optional configuration options.  A
typical configuration will look like:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">rejester</span><span class="p-Indicator">:</span>
  <span class="c1"># required rejester configuration</span>
  <span class="l-Scalar-Plain">registry_addresses</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span> <span class="s">&#39;redis.example.com:6379&#39;</span> <span class="p-Indicator">]</span>
  <span class="l-Scalar-Plain">app_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">rejester</span>
  <span class="l-Scalar-Plain">namespace</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">namespace</span>

  <span class="c1"># indicate which worker to use</span>
  <span class="l-Scalar-Plain">worker</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fork_worker</span>
  <span class="l-Scalar-Plain">fork_worker</span><span class="p-Indicator">:</span>
    <span class="c1"># set this or num_workers; num_workers takes precedence</span>
    <span class="l-Scalar-Plain">num_workers_per_core</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
    <span class="c1"># how often to check if there is more work</span>
    <span class="l-Scalar-Plain">poll_interval</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
    <span class="c1"># how often to start more workers</span>
    <span class="l-Scalar-Plain">spawn_interval</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">0.01</span>
    <span class="c1"># how often to record our existence</span>
    <span class="l-Scalar-Plain">heartbeat_interval</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">15</span>
    <span class="c1"># minimum time a working worker will live</span>
    <span class="l-Scalar-Plain">child_lifetime</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10</span>
    <span class="c1"># kill off jobs this long before their deadlines</span>
    <span class="l-Scalar-Plain">stop_jobs_early</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">15</span>
</pre></div>
</div>
<p>This spawns child processes to do work.  Each child process does at
most one work unit.  If <cite>num_workers</cite> is set, at most this many
concurrent workers will be running at a time.  If <cite>num_workers</cite> is
not set but <cite>num_workers_per_core</cite> is, the maximum number of workers
is a multiple of the number of processor cores available.  The
default setting is 1 worker per core, but setting this higher can
be beneficial if jobs are alternately network- and CPU-bound.</p>
<p>The parent worker runs a fairly simple state machine.  It awakens
on startup, whenever a child process exits, or after a timeout.
When it awakens, it checks on the status of all of its children,
and collects the exit status of those that have finished.  If any
failed or reported no more work, the timeout is set to
<cite>poll_interval</cite>, and no more workers are started until that
timeout has passed.  Otherwise, if it is not running the maximum
number of workers, it starts one exactly and sets the timeout to
<cite>spawn_interval</cite>.</p>
<p>This means that if the system is operating normally, and there is
work to do, then it will start all of its workers in <cite>num_workers</cite>
times <cite>spawn_interval</cite> time.  If <cite>spawn_interval</cite> is 0, then any
time the system thinks it may have work to do, it will spawn the
maximum number of processes immediately, each of which will
connect to Redis.  If the system runs out of work, or if it starts
all of its workers, it will check for work or system shutdown
every <cite>poll_interval</cite>.  The parent worker will contact Redis,
recording its state and retrieving the global mode, every
<cite>heartbeat_interval</cite>.</p>
<p>Every <cite>heartbeat_interval</cite> the parent also checks on the jobs its
children are running.  If any of them are overdue now or being
worked on by other workers, the parent will kill them to avoid
having multiple workers doing the same work unit.  Furthermore, if
any childrens&#8217; jobs will expire within <cite>stop_jobs_early</cite> seconds,
those jobs will be killed too even if they aren&#8217;t expired yet, and
any jobs killed this way will be marked failed if they are still
owned by the same child worker.  If <cite>stop_jobs_early</cite> is at least
<cite>heartbeat_interval</cite>, this will reliably cause jobs that take
longer than the expiry interval (default 300 seconds) to be killed
off rather than retried.</p>
<dl class="method">
<dt id="rejester.workers.ForkWorker.set_signal_handlers">
<code class="descname">set_signal_handlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.set_signal_handlers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.set_signal_handlers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set some signal handlers.</p>
<p>These react reasonably to shutdown requests, and keep the
logging child alive.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.clear_signal_handlers">
<code class="descname">clear_signal_handlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.clear_signal_handlers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.clear_signal_handlers" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo <a class="reference internal" href="#rejester.workers.ForkWorker.set_signal_handlers" title="rejester.workers.ForkWorker.set_signal_handlers"><code class="xref py py-meth docutils literal"><span class="pre">set_signal_handlers()</span></code></a>.</p>
<p>Not only must this be done on shutdown, but after every fork
call too.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>level</em>, <em>message</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a log message via the child process.</p>
<p>The child process must already exist; call <a class="reference internal" href="#rejester.workers.ForkWorker.live_log_child" title="rejester.workers.ForkWorker.live_log_child"><code class="xref py py-meth docutils literal"><span class="pre">live_log_child()</span></code></a>
to make sure.  If it has died in a way we don&#8217;t expect then
this will raise <code class="xref py py-const docutils literal"><span class="pre">signal.SIGPIPE</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>group</em>, <em>message</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.debug"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Maybe write a debug-level log message.</p>
<p>In particular, this gets written if the hidden <cite>debug_worker</cite>
option contains <cite>group</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.log_spewer">
<code class="descname">log_spewer</code><span class="sig-paren">(</span><em>gconfig</em>, <em>fd</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.log_spewer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.log_spewer" title="Permalink to this definition">¶</a></dt>
<dd><p>Child process to manage logging.</p>
<p>This reads pairs of lines from <cite>fd</cite>, which are alternating
priority (Python integer) and message (unformatted string).</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.start_log_child">
<code class="descname">start_log_child</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.start_log_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.start_log_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the logging child process.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.stop_log_child">
<code class="descname">stop_log_child</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.stop_log_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.stop_log_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the logging child process.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.live_log_child">
<code class="descname">live_log_child</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.live_log_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.live_log_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the logging child process if it died.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.do_some_work">
<code class="descname">do_some_work</code><span class="sig-paren">(</span><em>can_start_more</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.do_some_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.do_some_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one cycle of the main loop.</p>
<p>If the log child has died, restart it.  If any of the worker
children have died, collect their status codes and remove them
from the child set.  If there is a worker slot available, start
exactly one child.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>can_start_more</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Allowed to start a child?</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Time to wait before calling this function again</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.check_spinning_children">
<code class="descname">check_spinning_children</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.check_spinning_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.check_spinning_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop children that are working on overdue jobs.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.stop_gracefully">
<code class="descname">stop_gracefully</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.stop_gracefully"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.stop_gracefully" title="Permalink to this definition">¶</a></dt>
<dd><p>Refuse to start more processes.</p>
<p>This runs in response to SIGINT or SIGTERM; if this isn&#8217;t a
background process, control-C and a normal <code class="docutils literal"><span class="pre">kill</span></code> command
cause this.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.stop_all_children">
<code class="descname">stop_all_children</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.stop_all_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.stop_all_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Kill all workers.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.scram">
<code class="descname">scram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.scram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.scram" title="Permalink to this definition">¶</a></dt>
<dd><p>Kill all workers and die ourselves.</p>
<p>This runs in response to SIGABRT, from a specific invocation
of the <code class="docutils literal"><span class="pre">kill</span></code> command.  It also runs if
<a class="reference internal" href="#rejester.workers.ForkWorker.stop_gracefully" title="rejester.workers.ForkWorker.stop_gracefully"><code class="xref py py-meth docutils literal"><span class="pre">stop_gracefully()</span></code></a> is called more than once.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.workers.ForkWorker.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#ForkWorker.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.ForkWorker.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the main loop.</p>
<p>This is fairly invasive: it sets a bunch of signal handlers
and spawns off a bunch of child processes.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="rejester.workers.run_worker">
<code class="descclassname">rejester.workers.</code><code class="descname">run_worker</code><span class="sig-paren">(</span><em>worker_class</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/workers.html#run_worker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.workers.run_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bridge function to run a worker under <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a>.</p>
<p>The <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> module cannot
<code class="xref py py-meth docutils literal"><span class="pre">apply_async()</span></code> to a class constructor,
even if the <code class="docutils literal"><span class="pre">__init__</span></code> calls <code class="docutils literal"><span class="pre">.run()</span></code>, so this simple wrapper
calls <code class="docutils literal"><span class="pre">worker_class(*args,</span> <span class="pre">**kwargs)</span></code> and logs any exceptions
before re-raising them.</p>
<p>This is usually only used to create a <a class="reference internal" href="#rejester.workers.HeadlessWorker" title="rejester.workers.HeadlessWorker"><code class="xref py py-class docutils literal"><span class="pre">HeadlessWorker</span></code></a>, but
it does run through the complete
<a class="reference internal" href="#rejester.Worker.register" title="rejester.Worker.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a>, <a class="reference internal" href="#rejester.Worker.run" title="rejester.Worker.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>,
<a class="reference internal" href="#rejester.Worker.unregister" title="rejester.Worker.unregister"><code class="xref py py-meth docutils literal"><span class="pre">unregister()</span></code></a> sequence with some logging
on worker-level failures.</p>
</dd></dl>

</div>
<div class="section" id="implementation-details">
<h3>7.4.3. Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rejester.Registry">
<em class="property">class </em><code class="descclassname">rejester.</code><code class="descname">Registry</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._redis.RedisBase</span></code></p>
<p>Store string-keyed dictionaries in Redis.</p>
<p>Provides a centralized storage mechanism for dictionaries,
including atomic operations for moving (key, value) pairs between
dictionaries, and incrementing counts.</p>
<p>Many operations on the registry require getting a lock via
the database, for instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">value</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
</pre></div>
</div>
<p>The lock mechanism ensures that no two Registry objects do work
concurrently, even running on separate systems.  Specific method
descriptions will note if they can run without a lock.  In
general, read-only operations will always run successfully without
a lock but will check for the correct lock if one is given;
certain very simple operations do no lock checking at all; and
read-write operations always require a lock.</p>
<p>The basic data object is a string-keyed dictionary stored under
some key.  The dictionary keys are also stored in a prioritized
list.  This in effect provides two levels of dictionary, using the
Redis key and the dictionary key.  The registry makes an effort to
store all types of object as values, serializing them into CBOR.</p>
<dl class="method">
<dt id="rejester.Registry.re_acquire_lock">
<code class="descname">re_acquire_lock</code><span class="sig-paren">(</span><em>ltime=5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.re_acquire_lock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.re_acquire_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-acquire the lock.</p>
<p>You must already own the lock; this is best called from
within a <a class="reference internal" href="#rejester.Registry.lock" title="rejester.Registry.lock"><code class="xref py py-meth docutils literal"><span class="pre">lock()</span></code></a> block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ltime</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum time (in seconds) to own lock</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the session lock identifier</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.EnvironmentError" title="rejester.exceptions.EnvironmentError">rejester.exceptions.EnvironmentError</a>:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">if we didn&#8217;t already own the lock</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.lock">
<code class="descname">lock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.lock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager to acquire the namespace global lock.</p>
<p>This is typically used for multi-step registry operations,
such as a read-modify-write sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">registry</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dict&#39;</span><span class="p">,</span> <span class="s">&#39;key&#39;</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;traceback&#39;</span><span class="p">]</span>
    <span class="n">session</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;dict&#39;</span><span class="p">,</span> <span class="s">&#39;key&#39;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>Callers may provide their own <cite>identifier</cite>; if they do, they
must ensure that it is reasonably unique (e.g., a UUID).
Using a stored worker ID that is traceable back to the lock
holder is a good practice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>atime</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum time (in seconds) to acquire lock</li>
<li><strong>ltime</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum time (in seconds) to own lock</li>
<li><strong>identifier</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; worker-unique identifier for the lock</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.read_lock">
<code class="descname">read_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.read_lock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out who currently owns the namespace global lock.</p>
<p>This is purely a diagnostic tool.  If you are trying to get
the global lock, it is better to just call <a class="reference internal" href="#rejester.Registry.lock" title="rejester.Registry.lock"><code class="xref py py-meth docutils literal"><span class="pre">lock()</span></code></a>, which
will atomically get the lock if possible and retry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">session identifier of the lock holder, or <code class="xref py py-const docutils literal"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.force_clear_lock">
<code class="descname">force_clear_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.force_clear_lock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.force_clear_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Kick out whoever currently owns the namespace global lock.</p>
<p>This is intended as purely a last-resort tool.  If another
process has managed to get the global lock for a very long time,
or if it requested the lock with a long expiration and then
crashed, this can make the system functional again.  If the
original lock holder is still alive, its session calls may fail
with exceptions.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>dict_name</em>, <em>mapping=None</em>, <em>priorities=None</em>, <em>expire=None</em>, <em>locks=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Add mapping to a dictionary, replacing previous values</p>
<p>Can be called with only dict_name and expire to refresh the
expiration time.</p>
<p>NB: locks are only enforced if present, so nothing prevents
another caller from coming in an modifying data without using
locks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mapping</strong> &#8211; a dict of keys and values to update in
dict_name.  Must be specified if priorities is specified.</li>
<li><strong>priorities</strong> &#8211; a dict with the same keys as those in
mapping that provides a numerical value indicating the
priority to assign to that key.  Default sets 0 for all keys.</li>
<li><strong>expire</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; if specified, then dict_name will be set to
expire in that many seconds.</li>
<li><strong>locks</strong> &#8211; a dict with the same keys as those in the
mapping.  Before making any particular update, this function
checks if a key is present in a &#8216;locks&#8217; table for this dict,
and if so, then its value must match the value provided in the
input locks dict for that key.  If not, then the value
provided in the locks dict is inserted into the &#8216;locks&#8217; table.
If the locks parameter is None, then no lock checking is
performed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.reset_priorities">
<code class="descname">reset_priorities</code><span class="sig-paren">(</span><em>dict_name</em>, <em>priority</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.reset_priorities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.reset_priorities" title="Permalink to this definition">¶</a></dt>
<dd><p>set all priorities in dict_name to priority</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.popmany">
<code class="descname">popmany</code><span class="sig-paren">(</span><em>dict_name</em>, <em>*keys</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.popmany"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.popmany" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove one or more keys from a dictionary.</p>
<p>If any of the <cite>keys</cite> are not present, they are silently ignored.</p>
<p>The actual deletion operation is atomic and does not require a
session lock, but nothing stops another operation from creating
the deleted keys immediately afterwards.  You may call this with
or without a session lock, but the operation will fail if some
other worker holds one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of dictionary to modify</li>
<li><strong>keys</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; names of keys to remove</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">number of keys removed</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.LockError" title="rejester.exceptions.LockError">rejester.exceptions.LockError</a>:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first last">if the session lock timed
out, or if this was called without a session lock and some other
worker holds one</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.len">
<code class="descname">len</code><span class="sig-paren">(</span><em>dict_name</em>, <em>priority_min='-inf'</em>, <em>priority_max='+inf'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.len"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of items in (part of) a dictionary.</p>
<p>Returns number of items in <cite>dict_name</cite> within
[<cite>priority_min</cite>, <cite>priority_max</cite>].  This is similar to
<code class="docutils literal"><span class="pre">len(filter(dict_name,</span> <span class="pre">priority_min,</span> <span class="pre">priority_max))</span></code> but
does not actually retrieve the items.</p>
<p>This is a read-only operation that does not require or
honor a session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; dictionary name to query</li>
<li><strong>priority_min</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; lowest priority score</li>
<li><strong>priority_max</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; highest priority score</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.getitem_reset">
<code class="descname">getitem_reset</code><span class="sig-paren">(</span><em>dict_name</em>, <em>priority_min='-inf'</em>, <em>priority_max='+inf'</em>, <em>new_priority=0</em>, <em>lock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.getitem_reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.getitem_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Select an item and update its priority score.</p>
<p>The item comes from <cite>dict_name</cite>, and has the lowest score at
least <cite>priority_min</cite> and at most <cite>priority_max</cite>.  If some item
is found, change its score to <cite>new_priority</cite> and return it.</p>
<p>This runs as a single atomic operation but still requires a
session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; source dictionary</li>
<li><strong>priority_min</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; lowest score</li>
<li><strong>priority_max</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; highest score</li>
<li><strong>new_priority</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; new score</li>
<li><strong>lock</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; lock value for the item</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pair of (key, value) if an item was reprioritized, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><em>dict_name</em>, <em>priority_min='-inf'</em>, <em>priority_max='+inf'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.popitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Select an item and remove it.</p>
<p>The item comes from <cite>dict_name</cite>, and has the lowest score
at least <cite>priority_min</cite> and at most <cite>priority_max</cite>.  If some
item is found, remove it from <cite>dict_name</cite> and return it.</p>
<p>This runs as a single atomic operation but still requires a
session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; source dictionary</li>
<li><strong>priority_min</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; lowest score</li>
<li><strong>priority_max</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; highest score</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pair of (key, value) if an item was popped, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.popitem_move">
<code class="descname">popitem_move</code><span class="sig-paren">(</span><em>from_dict</em>, <em>to_dict</em>, <em>priority_min='-inf'</em>, <em>priority_max='+inf'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.popitem_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.popitem_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Select an item and move it to another dictionary.</p>
<p>The item comes from <cite>from_dict</cite>, and has the lowest score
at least <cite>priority_min</cite> and at most <cite>priority_max</cite>.  If some
item is found, remove it from <cite>from_dict</cite>, add it to <cite>to_dict</cite>,
and return it.</p>
<p>This runs as a single atomic operation but still requires a
session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; source dictionary</li>
<li><strong>to_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; destination dictionary</li>
<li><strong>priority_min</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; lowest score</li>
<li><strong>priority_max</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; highest score</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pair of (key, value) if an item was moved, or
<code class="xref py py-const docutils literal"><span class="pre">None</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>from_dict</em>, <em>to_dict</em>, <em>mapping</em>, <em>priority=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move keys between dictionaries, possibly with changes.</p>
<p>Every key in <cite>mapping</cite> is removed from <cite>from_dict</cite>, and added to
<cite>to_dict</cite> with its corresponding value.  The priority will be
<cite>priority</cite>, if specified, or else its current priority.</p>
<p>This operation on its own is atomic and does not require a
session lock; however, it does require you to pass in the
values, which probably came from a previous query call.  If
you do not call this with a session lock but some other caller
has one, you will get <code class="xref py py-class docutils literal"><span class="pre">rejester.LockError</span></code>.  If you do
have a session lock, this will check that you still have it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of original dictionary</li>
<li><strong>to_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of target dictionary</li>
<li><strong>mapping</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; keys to move with new values</li>
<li><strong>priority</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; target priority, or <code class="xref py py-const docutils literal"><span class="pre">None</span></code> to use existing</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>rejester.LockError</strong> &#8211; if the session lock timed out</li>
<li><strong>rejester.EnvironmentError</strong> &#8211; if some items didn&#8217;t move</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.move_all">
<code class="descname">move_all</code><span class="sig-paren">(</span><em>from_dict</em>, <em>to_dict</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.move_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.move_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Move everything from one dictionary to another.</p>
<p>This can be expensive if the source dictionary is large.</p>
<p>This always requires a session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>from_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; source dictionary</li>
<li><strong>to_dict</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; destination dictionary</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.pull">
<code class="descname">pull</code><span class="sig-paren">(</span><em>dict_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.pull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.pull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the entire contents of a single dictionary.</p>
<p>This operates without a session lock, but is still atomic.  In
particular this will run even if someone else holds a session
lock and you do not.</p>
<p>This is only suitable for &#8220;small&#8221; dictionaries; if you have
hundreds of thousands of items or more, consider
<a class="reference internal" href="#rejester.Registry.filter" title="rejester.Registry.filter"><code class="xref py py-meth docutils literal"><span class="pre">filter()</span></code></a> instead to get a subset of a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the dictionary to retrieve</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">corresponding Python dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>dict_name</em>, <em>priority_min='-inf'</em>, <em>priority_max='+inf'</em>, <em>start=0</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subset of a dictionary.</p>
<p>This retrieves only keys with priority scores greater than or
equal to <cite>priority_min</cite> and less than or equal to <cite>priority_max</cite>.
Of those keys, it skips the first <cite>start</cite> ones, and then returns
at most <cite>limit</cite> keys.</p>
<p>With default parameters, this retrieves the entire dictionary,
making it a more expensive version of <a class="reference internal" href="#rejester.Registry.pull" title="rejester.Registry.pull"><code class="xref py py-meth docutils literal"><span class="pre">pull()</span></code></a>.  This can
be used to limit the dictionary by priority score, for instance
using the score as a time stamp and only retrieving values
before or after a specific time; or it can be used to get
slices of the dictionary if there are too many items to use
<a class="reference internal" href="#rejester.Registry.pull" title="rejester.Registry.pull"><code class="xref py py-meth docutils literal"><span class="pre">pull()</span></code></a>.</p>
<p>This is a read-only operation and does not require a session
lock, but if this is run in a session context, the lock will
be honored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the dictionary to retrieve</li>
<li><strong>priority_min</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; lowest score to retrieve</li>
<li><strong>priority_max</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; highest score to retrieve</li>
<li><strong>start</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of items to skip</li>
<li><strong>limit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of items to retrieve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corresponding (partial) Python dictionary</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises rejester.LockError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first last">if the session lock timed out</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.set_1to1">
<code class="descname">set_1to1</code><span class="sig-paren">(</span><em>dict_name</em>, <em>key1</em>, <em>key2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.set_1to1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.set_1to1" title="Permalink to this definition">¶</a></dt>
<dd><p>Set two keys to be equal in a 1-to-1 mapping.</p>
<p>Within <cite>dict_name</cite>, <cite>key1</cite> is set to <cite>key2</cite>, and <cite>key2</cite> is set
to <cite>key1</cite>.</p>
<p>This always requires a session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; dictionary to update</li>
<li><strong>key1</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; first key/value</li>
<li><strong>key2</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; second key/value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>dict_name</em>, <em>key</em>, <em>default=None</em>, <em>include_priority=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value for a specific key in a specific dictionary.</p>
<p>If <cite>include_priority</cite> is false (default), returns the value
for that key, or <cite>default</cite> (defaults to <code class="xref py py-const docutils literal"><span class="pre">None</span></code>) if it
is absent.  If <cite>include_priority</cite> is true, returns a pair of
the value and its priority, or of <cite>default</cite> and <code class="xref py py-const docutils literal"><span class="pre">None</span></code>.</p>
<p>This does not use or enforce the session lock, and is read-only,
but inconsistent results are conceivably possible if the caller
does not hold the lock and <cite>include_priority</cite> is set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of dictionary to query</li>
<li><strong>key</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; key in dictionary to query</li>
<li><strong>default</strong> &#8211; default value if <cite>key</cite> is absent</li>
<li><strong>include_priority</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; include score in results</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">value from dictionary, or pair of value and priority</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>dict_name</em>, <em>key</em>, <em>value</em>, <em>priority=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a single value for a single key.</p>
<p>This requires a session lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the dictionary to update</li>
<li><strong>key</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; key to update</li>
<li><strong>value</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; value to assign to <cite>key</cite></li>
<li><strong>priority</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; priority score for the value (if any)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>dict_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an entire dictionary.</p>
<p>This operation on its own is atomic and does not require a
session lock, but a session lock is honored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dict_name</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the dictionary to delete</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises <a class="reference internal" href="#rejester.exceptions.LockError" title="rejester.exceptions.LockError">rejester.exceptions.LockError</a>:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">if called with a session
lock, but the system does not currently have that lock; or if
called without a session lock but something else holds it</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rejester.Registry.direct_call">
<code class="descname">direct_call</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_registry.html#Registry.direct_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.Registry.direct_call" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a direct redis call against this Registry instances
namespaced keys.  This is low level is should only be used for
prototyping.</p>
<p>arg[0] = redis function
arg[1] = key &#8212; will be namespaced before execution
args[2:] = args to function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Returns raw return value of function:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Neither args nor return values are encoded/decoded</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="priority-queue-system">
<h2>7.5. Priority queue system<a class="headerlink" href="#priority-queue-system" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="rejester.RejesterQueue">
<em class="property">class </em><code class="descclassname">rejester.</code><code class="descname">RejesterQueue</code><span class="sig-paren">(</span><em>config</em>, <em>name</em>, <em>worker_id=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rejester._redis.RedisBase</span></code></p>
<p>A Redis-based priority queue.</p>
<p>Queue items should generally be (short) strings.  Each item has
some associated priority.  <code class="docutils literal"><span class="pre">check_out_item()</span></code> will return some
item with the highest available priority.  The item must be
<code class="docutils literal"><span class="pre">renew_item()</span></code> or <code class="docutils literal"><span class="pre">return_item()</span></code> within a specified
expiration limit, or the item will be lost and may be given to
another client.</p>
<p>If you have a queue item checked out, you may also reserve other
queue items.  This prevents other clients from checking out or
reserving these items.  When you return the main queue item, or if
your check out expires, reserved items will be released.</p>
<p>Since the queue is based on Redis, there may be multiple queue
clients on the same queue on different systems.  Each <code class="docutils literal"><span class="pre">RejesterQueue</span></code>
instance has a distinct worker ID, held in the <code class="docutils literal"><span class="pre">worker_id</span></code> property.
You can manually specify it in the constructor or manually set it;
otherwise, a unique ID will be obtained via the database on first use.</p>
<dl class="method">
<dt id="rejester.RejesterQueue.dump_queue">
<code class="descname">dump_queue</code><span class="sig-paren">(</span><em>*names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.dump_queue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.dump_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Debug-log some of the queues.</p>
<p><code class="docutils literal"><span class="pre">names</span></code> may include any of &#8220;worker&#8221;, &#8220;available&#8221;, &#8220;priorities&#8221;,
&#8220;expiration&#8221;, &#8220;workers&#8221;, or &#8220;reservations_ITEM&#8221; filling in some
specific item.</p>
</dd></dl>

<dl class="attribute">
<dt id="rejester.RejesterQueue.worker_id">
<code class="descname">worker_id</code><a class="headerlink" href="#rejester.RejesterQueue.worker_id" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique identifier for this queue instance and the items it owns.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.RejesterQueue.add_item">
<code class="descname">add_item</code><span class="sig-paren">(</span><em>item</em>, <em>priority</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.add_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.add_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <code class="docutils literal"><span class="pre">item</span></code> to this queue.</p>
<p>It will have the specified <code class="docutils literal"><span class="pre">priority</span></code> (highest priority runs
first).  If it is already in the queue, fail if it is checked
out or reserved, or change its priority to <code class="docutils literal"><span class="pre">priority</span></code>
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.RejesterQueue.check_out_item">
<code class="descname">check_out_item</code><span class="sig-paren">(</span><em>expiration</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.check_out_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.check_out_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the highest-priority item out of this queue.</p>
<p>Returns the item, or None if no items are available.  The item
must be either <code class="docutils literal"><span class="pre">return_item()</span></code> or <code class="docutils literal"><span class="pre">renew_item()</span></code> before
<code class="docutils literal"><span class="pre">expiration</span></code> seconds pass, or it will become available to
future callers.  The item will be marked as being owned by
<code class="docutils literal"><span class="pre">worker_id</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.RejesterQueue.renew_item">
<code class="descname">renew_item</code><span class="sig-paren">(</span><em>item</em>, <em>expiration</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.renew_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.renew_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the expiration time for <code class="docutils literal"><span class="pre">item</span></code>.</p>
<p>The item will remain checked out for <code class="docutils literal"><span class="pre">expiration</span></code> seconds
beyond the current time.  This queue instance must have
already checked out <code class="docutils literal"><span class="pre">item</span></code>, and this method can fail if
<code class="docutils literal"><span class="pre">item</span></code> is already overdue.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.RejesterQueue.return_item">
<code class="descname">return_item</code><span class="sig-paren">(</span><em>item</em>, <em>priority</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.return_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.return_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete work on an item from <code class="docutils literal"><span class="pre">check_out_item()</span></code>.</p>
<p>If this instance no longer owns <code class="docutils literal"><span class="pre">item</span></code>, raise <code class="docutils literal"><span class="pre">LostLease</span></code>.
If <code class="docutils literal"><span class="pre">priority</span></code> is None, the item is removed from the queue;
otherwise it is re-added with the specified priority.  Any
locked items associated with this item are unlocked.</p>
</dd></dl>

<dl class="method">
<dt id="rejester.RejesterQueue.reserve_items">
<code class="descname">reserve_items</code><span class="sig-paren">(</span><em>parent_item</em>, <em>*items</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/_queue.html#RejesterQueue.reserve_items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.RejesterQueue.reserve_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve a set of items until a parent item is returned.</p>
<p>Prevent <code class="docutils literal"><span class="pre">check_out_item()</span></code> from returning any of <code class="docutils literal"><span class="pre">items</span></code>
until <code class="docutils literal"><span class="pre">parent_item</span></code> is completed or times out.  For each
item, if it is not already checked out or reserved by some
other parent item, it is associated with <code class="docutils literal"><span class="pre">parent_item</span></code>, and
the reservation will be released when <code class="docutils literal"><span class="pre">parent_item</span></code>
completes or times out.  Returns a list that is a subset of
<code class="docutils literal"><span class="pre">items</span></code> for which we could get the reservation.</p>
<p>Raises <code class="docutils literal"><span class="pre">LostLease</span></code> if this queue instance no longer owns
<code class="docutils literal"><span class="pre">parent_item</span></code>.  If any of the items do not exist, they are
silently ignored.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rejester.exceptions">
<span id="exceptions"></span><h2>7.6. Exceptions<a class="headerlink" href="#module-rejester.exceptions" title="Permalink to this headline">¶</a></h2>
<p>Exceptions raised in various places in rejester.</p>
<dl class="exception">
<dt id="rejester.exceptions.RejesterException">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">RejesterException</code><a class="reference internal" href="../_modules/rejester/exceptions.html#RejesterException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.RejesterException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/exceptions.html#exceptions.Exception" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></a></p>
<p>base exception for rejester package</p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.EnvironmentError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">EnvironmentError</code><a class="reference internal" href="../_modules/rejester/exceptions.html#EnvironmentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.EnvironmentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>indicates that the registry lost a lock or experienced a similar
failure that probably indicates a network or remote server failure</p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.LockError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">LockError</code><a class="reference internal" href="../_modules/rejester/exceptions.html#LockError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.LockError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>attempt to get a lock exceeded acquire time (atime)</p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.NoSuchWorkSpecError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">NoSuchWorkSpecError</code><span class="sig-paren">(</span><em>work_spec_name</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/exceptions.html#NoSuchWorkSpecError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.NoSuchWorkSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>A <cite>TaskMaster</cite> function was called with a nonexistent work spec</p>
<dl class="attribute">
<dt id="rejester.exceptions.NoSuchWorkSpecError.work_spec_name">
<code class="descname">work_spec_name</code><em class="property"> = None</em><a class="headerlink" href="#rejester.exceptions.NoSuchWorkSpecError.work_spec_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the nonexistent work spec</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.NoSuchWorkUnitError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">NoSuchWorkUnitError</code><span class="sig-paren">(</span><em>work_unit_name</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/rejester/exceptions.html#NoSuchWorkUnitError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.NoSuchWorkUnitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>Valid work spec but invalid work unit.</p>
<p>This occurs when a <a class="reference internal" href="#rejester.TaskMaster" title="rejester.TaskMaster"><code class="xref py py-class docutils literal"><span class="pre">rejester.TaskMaster</span></code></a> function that
manipulates existing work units is called with a valid work spec name
but an invalid work unit name.</p>
<dl class="attribute">
<dt id="rejester.exceptions.NoSuchWorkUnitError.work_unit_name">
<code class="descname">work_unit_name</code><em class="property"> = None</em><a class="headerlink" href="#rejester.exceptions.NoSuchWorkUnitError.work_unit_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the nonexistent work unit</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.ProgrammerError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">ProgrammerError</code><a class="reference internal" href="../_modules/rejester/exceptions.html#ProgrammerError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.ProgrammerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.PriorityRangeEmpty">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">PriorityRangeEmpty</code><a class="reference internal" href="../_modules/rejester/exceptions.html#PriorityRangeEmpty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.PriorityRangeEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>given the priority_min/max, no item is available to be returned</p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.LostLease">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">LostLease</code><a class="reference internal" href="../_modules/rejester/exceptions.html#LostLease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.LostLease" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>worker waited too long between calls to update and another worker
got the WorkItem</p>
</dd></dl>

<dl class="exception">
<dt id="rejester.exceptions.ItemInUseError">
<em class="property">exception </em><code class="descclassname">rejester.exceptions.</code><code class="descname">ItemInUseError</code><a class="reference internal" href="../_modules/rejester/exceptions.html#ItemInUseError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rejester.exceptions.ItemInUseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rejester.exceptions.RejesterException" title="rejester.exceptions.RejesterException"><code class="xref py py-class docutils literal"><span class="pre">rejester.exceptions.RejesterException</span></code></a></p>
<p>tried to add an item to a queue that was already in use</p>
</dd></dl>

</div>
<div class="section" id="example-streamcorpus-simple-filter-stage">
<h2>7.7. Example: StreamCorpus Simple Filter Stage<a class="headerlink" href="#example-streamcorpus-simple-filter-stage" title="Permalink to this headline">¶</a></h2>
<p>Rejester makes it easy to run large batches of small jobs, such as a
couple million runs of tagging batches of 500 documents with an NER
tagger or filtering to smaller sets of documents.</p>
<p>As a simple example, we illustrate how to write a filter function as
an external stage and run it in AWS EC2.</p>
<p><a class="reference internal" href="streamcorpus_pipeline.html#module-streamcorpus_pipeline" title="streamcorpus_pipeline"><code class="xref py py-mod docutils literal"><span class="pre">streamcorpus_pipeline</span></code></a> has several built-in filters <a class="reference external" href="https://github.com/trec-kba/streamcorpus-pipeline/blob/master/streamcorpus_pipeline/_filters.py">source in github</a>.
You can create your own as external stages.  For example, see this <a class="reference external" href="https://github.com/trec-kba/streamcorpus-pipeline/blob/master/examples/filters_exact_match.py">exact name match filter</a>.</p>
<div class="highlight-py"><div class="highlight"><pre><span class="c">## use the newer regex engine</span>
<span class="kn">import</span> <span class="nn">regex</span> <span class="kn">as</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">string</span>

<span class="c">## make a unicode translation table to converts all punctuation to white space</span>
<span class="n">strip_punctuation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">),</span> <span class="s">u&quot; &quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">)</span>

<span class="n">white_space_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;\s+&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">strip_string</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="s">&#39;strips punctuation and repeated whitespace from unicode strings&#39;</span>
    <span class="k">return</span> <span class="n">white_space_re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">strip_punctuation</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">filter_exact_match</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">&#39;trivial string matcher using simple normalization and regex&#39;</span>

    <span class="n">config_name</span> <span class="o">=</span> <span class="s">&#39;filter_exact_match&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;match_strings_path&#39;</span><span class="p">)</span>
        <span class="n">match_strings</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">match_strings</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">strip_string</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">unicode</span><span class="p">,</span> <span class="n">match_strings</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(.|</span><span class="se">\n</span><span class="s">)*?(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">match_strings</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="s">&#39;only pass StreamItems that match&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matcher</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">strip_string</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">clean_visible</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">))):</span>
            <span class="k">return</span> <span class="n">si</span>


<span class="c">## this is how streamcorpus_pipeline finds the stage</span>
<span class="n">Stages</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;filter_exact_match&#39;</span><span class="p">:</span> <span class="n">filter_exact_match</span><span class="p">}</span>
</pre></div>
</div>
<p>To run this in rejester, you need to setup a <a class="reference external" href="http://redis.io/">redis server</a> (use version 2.8 or newer), and put the hostname
in your yaml configuration file:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">logging</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">root</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">level</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">INFO</span>

<span class="l-Scalar-Plain">rejester</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">namespace</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my_kba_filtering</span>
  <span class="l-Scalar-Plain">app_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">rejester</span>
  <span class="l-Scalar-Plain">registry_addresses</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;redis.example.com:6379&quot;</span><span class="p-Indicator">]</span>

<span class="l-Scalar-Plain">streamcorpus_pipeline</span><span class="p-Indicator">:</span>
  <span class="c1">## &quot;.&quot; means current working directory</span>
  <span class="l-Scalar-Plain">root_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">.</span>

  <span class="l-Scalar-Plain">tmp_dir_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">tmp</span>
  <span class="l-Scalar-Plain">cleanup_tmp_files</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>

  <span class="l-Scalar-Plain">external_stages_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">examples/filter_exact_match.py</span>

  <span class="l-Scalar-Plain">reader</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">from_s3_chunks</span>

  <span class="l-Scalar-Plain">incremental_transforms</span><span class="p-Indicator">:</span>
    <span class="c1">## remove all StreamItems that do not exactly match</span>
    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">filter_exact_match</span>

  <span class="l-Scalar-Plain">batch_transforms</span><span class="p-Indicator">:</span> <span class="p-Indicator">[]</span>

  <span class="l-Scalar-Plain">filter_exact_match</span><span class="p-Indicator">:</span>
    <span class="c1">## names ending in &quot;_path&quot; will be made absolute relative to the root_path</span>
    <span class="l-Scalar-Plain">match_strings_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my_match_strings.txt</span>

  <span class="l-Scalar-Plain">writers</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">to_s3_chunks</span><span class="p-Indicator">]</span>

  <span class="l-Scalar-Plain">from_s3_chunks</span><span class="p-Indicator">:</span>
    <span class="c1">## put paths to your own keys here; these files must be just the</span>
    <span class="c1">## access_key_id and secret_access_key strings without newlines</span>
    <span class="l-Scalar-Plain">aws_access_key_id_path</span><span class="p-Indicator">:</span>     <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-aws-s3.aws_access_key_id</span>
    <span class="l-Scalar-Plain">aws_secret_access_key_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-aws-s3.aws_secret_access_key</span>

    <span class="c1">## this is the location of the NIST&#39;s StreamCorpus</span>
    <span class="l-Scalar-Plain">bucket</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">aws-publicdatasets</span>
    <span class="l-Scalar-Plain">s3_path_prefix</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">trec/kba/kba-streamcorpus-2014-v0_3_0</span>

    <span class="l-Scalar-Plain">tries</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10</span>
    <span class="l-Scalar-Plain">input_format</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">streamitem</span>
    <span class="l-Scalar-Plain">streamcorpus_version</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v0_3_0</span>

    <span class="c1">## you need this key if you are processing NIST&#39;s StreamCorpus,</span>
    <span class="c1">## which is encrypted</span>
    <span class="l-Scalar-Plain">gpg_decryption_key_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-kba-rsa.gpg-key.private</span>

  <span class="l-Scalar-Plain">to_s3_chunks</span><span class="p-Indicator">:</span>

    <span class="c1">## put your own bucket and paths to your own keys here; these</span>
    <span class="c1">## files must be just the access_key_id and secret_access_key</span>
    <span class="c1">## strings without newlines</span>
    <span class="l-Scalar-Plain">aws_access_key_id_path</span><span class="p-Indicator">:</span>     <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-aws-s3.aws_access_key_id</span>
    <span class="l-Scalar-Plain">aws_secret_access_key_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-aws-s3.aws_secret_access_key</span>

    <span class="l-Scalar-Plain">bucket</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">aws-publicdatasets</span>
    <span class="l-Scalar-Plain">s3_path_prefix</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">trec/kba/kba-streamcorpus-2014-v0_3_0-to-delete</span>

    <span class="l-Scalar-Plain">output_name</span><span class="p-Indicator">:</span> <span class="s">&quot;%(date_hour)s/%(source)s-%(num)d-%(input_md5)s-%(md5)s&quot;</span>
    <span class="l-Scalar-Plain">tries</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10</span>
    <span class="l-Scalar-Plain">cleanup_tmp_files</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>

    <span class="c1">## you only need these keys if you are encrypting the data that</span>
    <span class="c1">## you are putting into your bucket; you need both if you require</span>
    <span class="c1">## verify_via_http, which fetches and decrypts to validate what</span>
    <span class="c1">## was saved.</span>
    <span class="l-Scalar-Plain">gpg_decryption_key_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-kba-rsa.gpg-key.private</span>
    <span class="l-Scalar-Plain">gpg_encryption_key_path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/trec-kba/keys/trec-kba-rsa.gpg-key.pub</span>
    <span class="l-Scalar-Plain">gpg_recipient</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">trec-kba</span>

    <span class="l-Scalar-Plain">verify_via_http</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</pre></div>
</div>
<p>Then, you can run the following commands to put tasks into the rejester queue:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">## populate the task queue with jobs</span>
streamcorpus_directory -c examples/streamcorpus-2014-v0_3_0-exact-match-example.yaml --file-lists list_of_s3_paths.txt

<span class="c">## try running one, to make sure it works locally</span>
rejester -c examples/streamcorpus-2014-v0_3_0-exact-match-example.yaml run_one

<span class="c">## launch a MultiWorker to use all the CPUs on this machine:</span>
rejester -c examples/streamcorpus-2014-v0_3_0-exact-match-example.yaml run_worker

<span class="c">## check on the status of your jobs</span>
rejester -c examples/streamcorpus-2014-v0_3_0-exact-match-example.yaml summary
</pre></div>
</div>
<p>If you are interested in SaltStack states for spinning up machines to
do this, reach out on <a class="reference external" href="mailto:streamcorpus&#37;&#52;&#48;googlegroups&#46;com">streamcorpus<span>&#64;</span>googlegroups<span>&#46;</span>com</a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. <code class="docutils literal"><span class="pre">rejester</span></code> &#8212; Redis-based distributed work manager</a><ul>
<li><a class="reference internal" href="#module-rejester.run">7.1. <strong class="command">rejester</strong> tool</a></li>
<li><a class="reference internal" href="#module-rejester.run_multi_worker">7.2. <strong class="command">rejester_worker</strong> tool</a></li>
<li><a class="reference internal" href="#configuration">7.3. Configuration</a></li>
<li><a class="reference internal" href="#task-system">7.4. Task system</a><ul>
<li><a class="reference internal" href="#core-api">7.4.1. Core API</a></li>
<li><a class="reference internal" href="#workers">7.4.2. Workers</a></li>
<li><a class="reference internal" href="#implementation-details">7.4.3. Implementation Details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#priority-queue-system">7.5. Priority queue system</a></li>
<li><a class="reference internal" href="#module-rejester.exceptions">7.6. Exceptions</a></li>
<li><a class="reference internal" href="#example-streamcorpus-simple-filter-stage">7.7. Example: StreamCorpus Simple Filter Stage</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="kvlayer.html"
                        title="previous chapter">6. <code class="docutils literal"><span class="pre">kvlayer</span></code> &#8212; database abstraction for key/value stores</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/sphinx-docs/rejester.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="kvlayer.html" title="6. kvlayer — database abstraction for key/value stores"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">streamcorpus-pipeline 0.7.10.dev1 documentation</a> &raquo;</li> 
      </ul>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50390027-1', 'streamcorpus.org');
  ga('send', 'pageview');

</script>

  </body>
</html>